<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ReturnFeed Live</title>
    
    <!-- 폰트 로드 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gmarket+Sans+TTF:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --color-pvw: #00A36C;
            --color-pgm: #D41728;
            --tally-border-width: 10px;
            --color-blue: #00c6ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Gmarket Sans TTF', sans-serif;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* 스플래시 화면 */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .logo-container {
            animation: pulse 2s infinite;
        }

        .logo-text {
            font-family: 'Gmarket Sans TTF', sans-serif;
            font-size: 32px;
            font-weight: 700;
            fill: white;
        }

        .logo-text .feed {
            fill: var(--color-blue);
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.8; 
                transform: scale(1.05);
            }
        }

        /* 설정 화면 */
        .setup-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            text-align: center;
        }

        .setup-screen.active {
            display: flex;
        }

        .setup-logo {
            margin-bottom: 2rem;
        }

        .setup-status {
            font-size: 1.125rem;
            color: #9ca3af;
            margin-bottom: 2rem;
            height: 1.75rem;
            transition: opacity 0.3s ease;
        }

        .setup-form {
            width: 100%;
            max-width: 24rem;
            transition: all 0.5s ease;
            opacity: 0;
            transform: translateY(-1rem);
        }

        .setup-form.ready {
            opacity: 1;
            transform: translateY(0);
        }

        .setup-label {
            display: block;
            text-align: left;
            font-size: 1.125rem;
            font-weight: 500;
            color: #e5e7eb;
            margin-bottom: 0.75rem;
        }

        .setup-select {
            background: #374151;
            border: 2px solid #4b5563;
            color: white;
            font-size: 1.25rem;
            border-radius: 0.5rem;
            width: 100%;
            padding: 1rem;
            appearance: none;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .setup-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .setup-select option {
            background: #374151;
            color: white;
            padding: 0.5rem;
        }

        /* 플레이어 화면 */
        .player-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            display: none;
        }

        .player-screen.active {
            display: block;
        }

        /* 비디오 컨테이너 */
        .video-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000000;
            overflow: hidden;
        }

        .video-element {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #000000;
        }

        /* 탈리 오버레이 */
        .tally-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            transition: box-shadow 0.3s ease-in-out;
        }

        .tally-container.pgm-tally {
            box-shadow: 0 0 0 var(--tally-border-width) var(--color-pgm) inset;
        }

        .tally-container.pvw-tally {
            box-shadow: 0 0 0 var(--tally-border-width) var(--color-pvw) inset;
        }

        .tally-container.flash-pgm {
            animation: flash-pgm-anim 0.5s ease-out;
        }

        .tally-container.flash-pvw {
            animation: flash-pvw-anim 0.5s ease-out;
        }

        @keyframes flash-pgm-anim {
            0% { 
                box-shadow: 0 0 0 var(--tally-border-width) #ff7979 inset; 
            }
            100% { 
                box-shadow: 0 0 0 var(--tally-border-width) var(--color-pgm) inset; 
            }
        }

        @keyframes flash-pvw-anim {
            0% { 
                box-shadow: 0 0 0 var(--tally-border-width) #2ecc71 inset; 
            }
            100% { 
                box-shadow: 0 0 0 var(--tally-border-width) var(--color-pvw) inset; 
            }
        }

        /* CAM 타이틀 */
        .cam-title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Gmarket Sans TTF', sans-serif;
            font-size: clamp(4rem, 15vw, 12rem);
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 
                0 0 30px rgba(0, 0, 0, 0.8),
                0 4px 15px rgba(0, 0, 0, 0.6);
            z-index: 15;
            opacity: 0;
            transition: all 0.4s ease;
            pointer-events: none;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .cam-title.visible {
            opacity: 1;
        }

        /* 오버레이 컨트롤 */
        .overlay-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.6) 70%, rgba(0,0,0,0) 100%);
            padding: 3rem 1.5rem 1.5rem;
            z-index: 30;
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.4s ease;
            backdrop-filter: blur(10px);
        }

        .overlay-controls.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* 설정 그리드 */
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 0.75rem;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
        }

        .setting-item:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .setting-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
        }

        /* 토글 스위치 */
        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #4a5568;
            transition: 0.4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #38a169;
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        /* 상태 표시 */
        .status-bar {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1.5rem;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 25;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
            animation: pulse-dot 2s infinite;
        }

        .status-dot.connected {
            background: #10b981;
        }

        .status-dot.connecting {
            background: #f59e0b;
        }

        @keyframes pulse-dot {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.6; 
                transform: scale(1.1);
            }
        }

        /* 성능 모니터 */
        .performance-monitor {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.8);
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            font-size: 0.7rem;
            color: #9ca3af;
            z-index: 25;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 500;
        }

        .performance-monitor.visible {
            opacity: 1;
        }

        .performance-monitor div {
            margin-bottom: 0.25rem;
        }

        .performance-monitor div:last-child {
            margin-bottom: 0;
        }

        /* 터치 영역 */
        .touch-area {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 5;
            cursor: pointer;
        }

        /* 로딩 스피너 */
        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top: 3px solid var(--color-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 15;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* 음성 디버그 표시 */
        .voice-debug {
            position: absolute;
            top: 4rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.9);
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.7rem;
            color: #10b981;
            z-index: 25;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(16, 185, 129, 0.3);
            font-weight: 500;
        }

        .voice-debug.visible {
            opacity: 1;
        }

        /* 반응형 디자인 */
        @media (max-width: 768px) {
            :root {
                --tally-border-width: 8px;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }
            
            .overlay-controls {
                padding: 2.5rem 1rem 1rem;
            }
            
            .status-bar {
                top: 0.75rem;
                right: 0.75rem;
                padding: 0.4rem 0.8rem;
                font-size: 0.75rem;
            }
            
            .performance-monitor {
                bottom: 0.75rem;
                left: 0.75rem;
                padding: 0.6rem 0.8rem;
                font-size: 0.65rem;
            }

            .voice-debug {
                top: 3rem;
                right: 0.75rem;
                padding: 0.4rem 0.6rem;
                font-size: 0.65rem;
            }
        }

        @media (max-width: 480px) {
            .setup-screen {
                padding: 1.5rem;
            }
            
            .setup-select {
                font-size: 1.1rem;
                padding: 0.9rem;
            }
            
            .setting-item {
                padding: 0.9rem 1rem;
            }
            
            .setting-label {
                font-size: 0.85rem;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .overlay-controls {
                padding: 2rem 1rem 0.75rem;
            }
            
            .cam-title {
                font-size: clamp(3rem, 12vw, 8rem);
            }
        }

        /* 다크 모드 최적화 */
        @media (prefers-color-scheme: dark) {
            .setup-screen {
                background: #0a0a0a;
            }
        }

        /* 고대비 모드 지원 */
        @media (prefers-contrast: high) {
            .setting-item {
                border-width: 2px;
            }
            
            .status-bar {
                border-width: 2px;
            }
        }

        /* 애니메이션 감소 모드 */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* 터치 디바이스 최적화 */
        @media (hover: none) and (pointer: coarse) {
            .setting-item:hover {
                transform: none;
                background: rgba(255, 255, 255, 0.08);
            }
        }
    </style>
</head>
<body>
    <!-- 스플래시 화면 -->
    <div class="splash-screen" id="splashScreen">
        <div class="logo-container">
            <svg width="200" height="50" viewBox="0 0 200 50">
                <text x="0" y="35" class="logo-text">
                    Return<tspan class="feed">Feed</tspan>
                </text>
            </svg>
        </div>
    </div>

    <!-- 설정 화면 -->
    <div class="setup-screen" id="setupScreen">
        <div class="setup-logo">
            <svg width="200" height="50" viewBox="0 0 200 50">
                <text x="0" y="35" class="logo-text">
                    Return<tspan class="feed">Feed</tspan>
                </text>
            </svg>
        </div>
        <p class="setup-status" id="setupStatus">서버에 연결하는 중...</p>
        <div class="setup-form" id="setupForm">
            <label for="cameraSelect" class="setup-label">카메라 선택</label>
            <select id="cameraSelect" class="setup-select">
                <option value="" disabled selected>담당할 카메라를 선택하세요</option>
                <option value="1:CAM 1">CAM 1: 3루캠.mp4</option>
                <option value="2:CAM 2">CAM 2: 배터리샷.mp4</option>
                <option value="3:CAM 3">CAM 3: 볼트래킹.mp4</option>
                <option value="4:CAM 4">CAM 4: 심판캠.mp4</option>
                <option value="5:CAM 5">CAM 5: 리플레이저장 연습용</option>
                <option value="6:CAM 6">CAM 6: 리플레이저장 연습용</option>
                <option value="0:PGM Only" class="border-t">---</option>
                <option value="0:PGM Only">PGM만 보기 (Tally 기능 OFF)</option>
            </select>
        </div>
    </div>

    <!-- 플레이어 화면 -->
    <div class="player-screen" id="playerScreen">
        <!-- 비디오 컨테이너 -->
        <div class="video-container">
            <video class="video-element" id="videoElement" autoplay muted playsinline></video>
            <div class="tally-container" id="tallyContainer"></div>
            <div class="loading-spinner" id="loadingSpinner" style="display: none;"></div>
        </div>

        <!-- CAM 타이틀 -->
        <div class="cam-title" id="camTitle">CAM 1</div>

        <!-- 상태 표시 -->
        <div class="status-bar">
            <div class="status-dot" id="statusDot"></div>
            <span id="connectionText">연결 중...</span>
        </div>

        <!-- 음성 디버그 표시 -->
        <div class="voice-debug" id="voiceDebug">음성: 대기 중</div>

        <!-- 성능 모니터 -->
        <div class="performance-monitor" id="performanceMonitor">
            <div>RTT: <span id="rttCounter">N/A</span></div>
            <div>Bitrate: <span id="bitrateCounter">N/A</span></div>
            <div>상태: <span id="statusIndicator">연결 중</span></div>
        </div>

        <!-- 오버레이 컨트롤 -->
        <div class="overlay-controls" id="overlayControls">
            <!-- 설정 그리드 -->
            <div class="settings-grid">
                <div class="setting-item">
                    <span class="setting-label">진동</span>
                    <label class="switch">
                        <input type="checkbox" id="vibrationToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <span class="setting-label">음성안내</span>
                    <label class="switch">
                        <input type="checkbox" id="audioToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <span class="setting-label">절약모드</span>
                    <label class="switch">
                        <input type="checkbox" id="conserveToggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <span class="setting-label">성능표시</span>
                    <label class="switch">
                        <input type="checkbox" id="performanceToggle">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
        </div>

        <!-- 터치 영역 -->
        <div class="touch-area" id="touchArea"></div>
    </div>

    <script>
        class AdvancedAudioSystem {
            constructor() {
                this.isInitialized = false;
                this.currentUtterance = null;
                this.speechQueue = [];
                this.maleVoices = [];
                this.selectedVoice = null;
                this.isProcessing = false;
                this.debugElement = null;
                
                this.init();
            }

            async init() {
                this.debugElement = document.getElementById('voiceDebug');
                await this.initializeSpeechSynthesis();
                this.setupVoiceChangeListener();
                this.isInitialized = true;
                this.updateDebug('시스템 준비됨');
            }

            async initializeSpeechSynthesis() {
                if (!('speechSynthesis' in window)) {
                    console.error('음성 합성을 지원하지 않는 브라우저입니다.');
                    this.updateDebug('음성 지원 안함');
                    return;
                }

                // 음성 목록 로드 대기
                await this.waitForVoices();
                this.loadMaleVoices();
                this.selectBestMaleVoice();
            }

            waitForVoices() {
                return new Promise((resolve) => {
                    const voices = speechSynthesis.getVoices();
                    if (voices.length > 0) {
                        resolve();
                        return;
                    }

                    const checkVoices = () => {
                        const voices = speechSynthesis.getVoices();
                        if (voices.length > 0) {
                            speechSynthesis.removeEventListener('voiceschanged', checkVoices);
                            resolve();
                        }
                    };

                    speechSynthesis.addEventListener('voiceschanged', checkVoices);
                    
                    // 타임아웃 설정 (5초)
                    setTimeout(() => {
                        speechSynthesis.removeEventListener('voiceschanged', checkVoices);
                        resolve();
                    }, 5000);
                });
            }

            setupVoiceChangeListener() {
                speechSynthesis.addEventListener('voiceschanged', () => {
                    this.loadMaleVoices();
                    this.selectBestMaleVoice();
                });
            }

            loadMaleVoices() {
                const allVoices = speechSynthesis.getVoices();
                console.log('전체 음성 목록:', allVoices.map(v => `${v.name} (${v.lang}) - ${v.gender || 'unknown'}`));

                // 남성 음성 키워드 (우선순위 순)
                const maleKeywords = [
                    // 명시적 남성 음성
                    'male', 'man', 'masculine',
                    // 특정 남성 음성 이름
                    'alex', 'daniel', 'david', 'fred', 'jorge', 'nathan', 'aaron', 'arthur',
                    'google uk english male', 'microsoft david', 'microsoft mark',
                    'samantha', 'tom', 'bruce', 'ralph', 'albert', 'bad news', 'bahh', 'bells',
                    'boing', 'bubbles', 'cellos', 'deranged', 'good news', 'hysterical',
                    'pipe organ', 'trinoids', 'whisper', 'zarvox'
                ];

                this.maleVoices = [];

                // 1단계: 명시적으로 남성으로 표시된 음성
                allVoices.forEach(voice => {
                    if (voice.gender === 'male' || voice.gender === 'masculine') {
                        this.maleVoices.push({ voice, priority: 1, reason: 'gender-male' });
                    }
                });

                // 2단계: 이름에 남성 키워드가 포함된 음성
                maleKeywords.forEach((keyword, index) => {
                    allVoices.forEach(voice => {
                        const voiceName = voice.name.toLowerCase();
                        if (voiceName.includes(keyword.toLowerCase()) && 
                            !this.maleVoices.some(mv => mv.voice.name === voice.name)) {
                            this.maleVoices.push({ 
                                voice, 
                                priority: 2 + index, 
                                reason: `keyword-${keyword}` 
                            });
                        }
                    });
                });

                // 3단계: 영어 음성 중 특정 패턴 (일반적으로 남성인 것들)
                const likelyMalePatterns = [
                    /^[A-Z][a-z]+ \(English/,  // 단순한 이름 패턴
                    /^English \(US\)/,         // 기본 영어 음성
                    /^English \(UK\)/          // 영국 영어 음성
                ];

                likelyMalePatterns.forEach((pattern, index) => {
                    allVoices.forEach(voice => {
                        if (pattern.test(voice.name) && 
                            voice.lang.startsWith('en') &&
                            !this.maleVoices.some(mv => mv.voice.name === voice.name)) {
                            this.maleVoices.push({ 
                                voice, 
                                priority: 100 + index, 
                                reason: 'pattern-match' 
                            });
                        }
                    });
                });

                // 우선순위로 정렬
                this.maleVoices.sort((a, b) => a.priority - b.priority);

                console.log('남성 음성 후보:', this.maleVoices.map(mv => 
                    `${mv.voice.name} (우선순위: ${mv.priority}, 이유: ${mv.reason})`
                ));
            }

            selectBestMaleVoice() {
                if (this.maleVoices.length === 0) {
                    // 남성 음성이 없으면 영어 음성 중 첫 번째 사용
                    const allVoices = speechSynthesis.getVoices();
                    const englishVoice = allVoices.find(voice => voice.lang.startsWith('en'));
                    this.selectedVoice = englishVoice || allVoices[0] || null;
                    this.updateDebug(`기본음성: ${this.selectedVoice?.name || '없음'}`);
                } else {
                    this.selectedVoice = this.maleVoices[0].voice;
                    this.updateDebug(`남성음성: ${this.selectedVoice.name}`);
                }

                console.log('선택된 음성:', this.selectedVoice);
            }

            // 마지막 명령 우선 처리 (기존 음성 즉시 중단)
            speak(text, priority = 'normal') {
                if (!this.isInitialized || !this.selectedVoice) {
                    console.warn('음성 시스템이 초기화되지 않았습니다.');
                    return;
                }

                // 기존 음성 즉시 중단 (마지막 명령 우선)
                this.stopCurrentSpeech();

                // 새 음성 생성
                const utterance = new SpeechSynthesisUtterance(text);
                this.currentUtterance = utterance;

                // 선택된 남성 음성 적용
                utterance.voice = this.selectedVoice;

                // 남성적인 음성 설정
                utterance.rate = 1.1;      // 약간 빠르게
                utterance.pitch = 0.5;     // 낮은 피치 (남성적)
                utterance.volume = 1.0;    // 최대 볼륨

                // 이벤트 핸들러
                utterance.onstart = () => {
                    this.isProcessing = true;
                    this.updateDebug(`재생중: ${text}`);
                    console.log(`음성 재생 시작: ${text}`);
                };

                utterance.onend = () => {
                    this.isProcessing = false;
                    this.currentUtterance = null;
                    this.updateDebug('재생 완료');
                    console.log(`음성 재생 완료: ${text}`);
                };

                utterance.onerror = (event) => {
                    this.isProcessing = false;
                    this.currentUtterance = null;
                    this.updateDebug(`오류: ${event.error}`);
                    console.error('음성 재생 오류:', event.error);
                };

                // 즉시 재생
                try {
                    speechSynthesis.speak(utterance);
                    console.log(`음성 명령 실행: ${text} (음성: ${this.selectedVoice.name})`);
                } catch (error) {
                    console.error('음성 재생 실패:', error);
                    this.updateDebug(`실패: ${error.message}`);
                }
            }

            stopCurrentSpeech() {
                if (speechSynthesis.speaking || speechSynthesis.pending) {
                    speechSynthesis.cancel();
                    console.log('기존 음성 중단됨');
                }
                
                this.currentUtterance = null;
                this.isProcessing = false;
            }

            updateDebug(message) {
                if (this.debugElement) {
                    this.debugElement.textContent = `음성: ${message}`;
                    this.debugElement.classList.add('visible');
                    
                    // 3초 후 숨김
                    setTimeout(() => {
                        this.debugElement.classList.remove('visible');
                    }, 3000);
                }
            }

            // 테스트 메서드
            testVoice(text = 'Test') {
                this.speak(text);
            }

            // 음성 목록 가져오기
            getAvailableVoices() {
                return speechSynthesis.getVoices();
            }

            // 현재 선택된 음성 정보
            getCurrentVoiceInfo() {
                return this.selectedVoice ? {
                    name: this.selectedVoice.name,
                    lang: this.selectedVoice.lang,
                    gender: this.selectedVoice.gender || 'unknown'
                } : null;
            }
        }

        class ReturnFeedApp {
            constructor() {
                this.currentView = 'splash';
                this.myCamera = null;
                this.inputList = {};
                this.tallyState = { program: null, preview: null };
                this.settings = this.loadSettings();
                this.isOverlayVisible = false;
                this.overlayTimeout = null;
                this.ws = null;
                this.pc = null;
                this.lastTallyState = { state: 'off', lastBytesReceived: 0, lastTimestamp: 0 };
                this.streamStats = { rtt: 'N/A', bitrate: 'N/A' };
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.audioContext = null;
                
                // 고급 음성 시스템 초기화
                this.audioSystem = new AdvancedAudioSystem();
                
                this.init();
            }

            async init() {
                await this.showSplashScreen();
                this.setupEventListeners();
                await this.initializeAudio();
                this.showSetupScreen();
                this.connectWebSocket();
            }

            async showSplashScreen() {
                // 1.2초 후 스플래시 화면 숨김
                await new Promise(resolve => setTimeout(resolve, 1200));
                document.getElementById('splashScreen').classList.add('hidden');
            }

            showSetupScreen() {
                document.getElementById('setupScreen').classList.add('active');
                this.animateSetupScreen();
            }

            async animateSetupScreen() {
                const statusElement = document.getElementById('setupStatus');
                const formElement = document.getElementById('setupForm');
                
                const steps = [
                    { text: "네트워크 상태 분석 중...", delay: 400 },
                    { text: "최적의 경로를 탐색합니다...", delay: 800 },
                    { text: "ReturnFeed 시스템 준비 완료", delay: 1200 }
                ];

                for (let i = 0; i < steps.length; i++) {
                    await new Promise(resolve => {
                        setTimeout(() => {
                            statusElement.textContent = steps[i].text;
                            if (i === steps.length - 1) {
                                statusElement.style.opacity = '0';
                                formElement.classList.add('ready');
                            }
                            resolve();
                        }, steps[i].delay);
                    });
                }
            }

            setupEventListeners() {
                // 카메라 선택
                document.getElementById('cameraSelect').addEventListener('change', (e) => {
                    this.handleCameraSelect(e.target.value);
                });

                // 터치 이벤트
                const touchArea = document.getElementById('touchArea');
                touchArea.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.toggleOverlay();
                }, { passive: false });

                touchArea.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.toggleOverlay();
                });

                // 설정 토글
                document.querySelectorAll('.switch input').forEach(toggle => {
                    toggle.addEventListener('change', (e) => {
                        this.handleSettingToggle(e.target.id, e.target.checked);
                    });
                });

                // 페이지 가시성 변경
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        this.reconnectIfNeeded();
                    }
                });

                // 네트워크 상태 변경
                window.addEventListener('online', () => {
                    console.log('네트워크 연결 복구됨');
                    this.reconnectAll();
                });

                window.addEventListener('offline', () => {
                    console.log('네트워크 연결 끊김');
                    this.updateConnectionStatus(false);
                });

                // 키보드 단축키 (테스트용)
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'KeyT' && e.ctrlKey) {
                        e.preventDefault();
                        this.audioSystem.testVoice('Test voice');
                    }
                    if (e.code === 'KeyS' && e.ctrlKey) {
                        e.preventDefault();
                        this.audioSystem.speak('Standby');
                    }
                    if (e.code === 'KeyC' && e.ctrlKey) {
                        e.preventDefault();
                        this.audioSystem.speak('Cut');
                    }
                });
            }

            async initializeAudio() {
                try {
                    // 오디오 컨텍스트 초기화 (사용자 상호작용 후)
                    document.addEventListener('touchstart', this.initAudioContext.bind(this), { once: true });
                    document.addEventListener('click', this.initAudioContext.bind(this), { once: true });
                } catch (error) {
                    console.error('오디오 초기화 실패:', error);
                }
            }

            initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('오디오 컨텍스트 초기화됨');
                } catch (error) {
                    console.error('오디오 컨텍스트 생성 실패:', error);
                }
            }

            handleCameraSelect(value) {
                if (!value) return;
                
                const [numStr, ...nameParts] = value.split(':');
                const camNumber = parseInt(numStr);
                const camName = nameParts.join(':');
                
                this.myCamera = { number: camNumber, name: camName };
                this.showPlayerScreen();
                
                if (camNumber === 0) {
                    this.settings.vibration = false;
                    this.settings.audio = false;
                    this.updateSettingsUI();
                }
            }

            showPlayerScreen() {
                document.getElementById('setupScreen').classList.remove('active');
                document.getElementById('playerScreen').classList.add('active');
                this.currentView = 'player';
                
                // CAM 타이틀 업데이트
                const title = this.myCamera.number === 0 ? 'PGM' : `CAM ${this.myCamera.number}`;
                document.getElementById('camTitle').textContent = title;
                
                // WebRTC 연결 시작
                this.startWebRTC();
                
                // 설정 복원
                this.updateSettingsUI();
            }

            async connectWebSocket() {
                try {
                    if (this.ws) {
                        this.ws.close();
                    }

                    this.updateConnectionStatus('connecting');
                    
                    this.ws = new WebSocket('wss://returnfeed.net/ws/');
                    
                    const connectionTimeout = setTimeout(() => {
                        if (this.ws.readyState === WebSocket.CONNECTING) {
                            this.ws.close();
                            console.log('WebSocket 연결 타임아웃');
                        }
                    }, 5000);

                    this.ws.onopen = () => {
                        clearTimeout(connectionTimeout);
                        console.log('WebSocket 연결됨');
                        this.updateConnectionStatus(true);
                        this.reconnectAttempts = 0;
                        
                        // 전체 상태 요청
                        this.ws.send(JSON.stringify({ command: 'get_full_state' }));
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketMessage(data);
                        } catch (e) {
                            console.error('WebSocket 메시지 파싱 오류:', e);
                        }
                    };

                    this.ws.onclose = (event) => {
                        clearTimeout(connectionTimeout);
                        console.log('WebSocket 연결 끊김:', event.code);
                        this.updateConnectionStatus(false);
                        
                        // 지수 백오프로 재연결
                        if (this.reconnectAttempts < this.maxReconnectAttempts) {
                            const delay = 1000 * Math.pow(2, this.reconnectAttempts);
                            setTimeout(() => {
                                this.reconnectAttempts++;
                                this.connectWebSocket();
                            }, delay);
                        }
                    };

                    this.ws.onerror = (error) => {
                        clearTimeout(connectionTimeout);
                        console.error('WebSocket 오류:', error);
                    };

                } catch (error) {
                    console.error('WebSocket 연결 실패:', error);
                    this.updateConnectionStatus(false);
                }
            }

            handleWebSocketMessage(data) {
                if (data.type === 'input_list' || data.type === 'full_state') {
                    this.inputList = data.inputs || {};
                    this.updateCameraOptions();
                }
                
                if (data.type === 'tally_update' || data.type === 'full_state') {
                    this.tallyState = { program: data.program, preview: data.preview };
                    this.updateTallyState();
                }
            }

            updateCameraOptions() {
                const select = document.getElementById('cameraSelect');
                const currentValue = select.value;
                
                // 기존 옵션 제거 (기본 옵션 제외)
                while (select.children.length > 1) {
                    select.removeChild(select.lastChild);
                }
                
                // 새 옵션 추가
                Object.entries(this.inputList).forEach(([num, name]) => {
                    const option = document.createElement('option');
                    option.value = `${num}:${name}`;
                    option.textContent = `CAM ${num}: ${name.substring(0, 15)}${name.length > 15 ? '...' : ''}`;
                    select.appendChild(option);
                });
                
                // 구분선 및 PGM 옵션
                const separator = document.createElement('option');
                separator.value = '';
                separator.textContent = '---';
                separator.disabled = true;
                select.appendChild(separator);
                
                const pgmOption = document.createElement('option');
                pgmOption.value = '0:PGM Only';
                pgmOption.textContent = 'PGM만 보기 (Tally 기능 OFF)';
                select.appendChild(pgmOption);
                
                // 이전 선택값 복원
                if (currentValue) {
                    select.value = currentValue;
                }
            }

            updateTallyState() {
                if (!this.myCamera || this.currentView !== 'player') return;
                
                let currentTally = 'off';
                if (this.myCamera.number !== 0) {
                    if (this.myCamera.number === this.tallyState.program) {
                        currentTally = 'pgm';
                    } else if (this.myCamera.number === this.tallyState.preview) {
                        currentTally = 'pvw';
                    }
                }
                
                // 상태 변경 시에만 처리
                if (this.lastTallyState.state !== currentTally) {
                    this.lastTallyState.state = currentTally;
                    this.applyTallyVisual(currentTally);
                    this.triggerFeedback(currentTally);
                }
            }

            applyTallyVisual(state) {
                const container = document.getElementById('tallyContainer');
                
                // 기존 클래스 제거
                container.className = 'tally-container';
                
                if (state === 'pgm') {
                    container.classList.add('pgm-tally', 'flash-pgm');
                    setTimeout(() => container.classList.remove('flash-pgm'), 500);
                } else if (state === 'pvw') {
                    container.classList.add('pvw-tally', 'flash-pvw');
                    setTimeout(() => container.classList.remove('flash-pvw'), 500);
                }
            }

            triggerFeedback(state) {
                // 진동 피드백
                if (this.settings.vibration && navigator.vibrate) {
                    if (state === 'pvw') {
                        navigator.vibrate([80, 40, 80]); // 짧게 두 번
                    } else if (state === 'pgm') {
                        navigator.vibrate(250); // 길게 한 번
                    }
                }

                // 음성 안내 (개선된 시스템 사용)
                if (this.settings.audio) {
                    this.playAudioGuide(state);
                }
            }

            playAudioGuide(state) {
                if (state === 'pvw') {
                    this.audioSystem.speak('Standby', 'high');
                } else if (state === 'pgm') {
                    this.audioSystem.speak('Cut', 'high');
                }
                // off 상태에서는 음성 없음
            }

            async startWebRTC() {
                try {
                    document.getElementById('loadingSpinner').style.display = 'block';
                    
                    if (this.pc) {
                        this.pc.close();
                    }

                    const configuration = {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ],
                        iceCandidatePoolSize: 10,
                        bundlePolicy: 'max-bundle',
                        rtcpMuxPolicy: 'require'
                    };

                    this.pc = new RTCPeerConnection(configuration);

                    this.pc.onconnectionstatechange = () => {
                        console.log('WebRTC 연결 상태:', this.pc.connectionState);
                        
                        if (this.pc.connectionState === 'connected') {
                            this.updateConnectionStatus(true);
                            document.getElementById('loadingSpinner').style.display = 'none';
                            document.getElementById('statusIndicator').textContent = '연결됨';
                        } else if (this.pc.connectionState === 'failed' || 
                                   this.pc.connectionState === 'disconnected') {
                            this.updateConnectionStatus(false);
                            document.getElementById('statusIndicator').textContent = '연결 실패';
                            setTimeout(() => this.reconnectWebRTC(), 1000);
                        }
                    };

                    this.pc.ontrack = (event) => {
                        console.log('스트림 수신됨');
                        const video = document.getElementById('videoElement');
                        
                        if (event.streams && event.streams[0]) {
                            video.srcObject = event.streams[0];
                            
                            const playPromise = video.play();
                            
                            if (playPromise !== undefined) {
                                playPromise.then(() => {
                                    console.log('비디오 재생 시작됨');
                                    document.getElementById('loadingSpinner').style.display = 'none';
                                    this.startStatsMonitoring();
                                }).catch(e => {
                                    console.log('자동 재생 실패:', e);
                                    const playOnTouch = () => {
                                        video.play().then(() => {
                                            document.getElementById('loadingSpinner').style.display = 'none';
                                            this.startStatsMonitoring();
                                        });
                                        document.removeEventListener('touchstart', playOnTouch);
                                        document.removeEventListener('click', playOnTouch);
                                    };
                                    
                                    document.addEventListener('touchstart', playOnTouch, { once: true });
                                    document.addEventListener('click', playOnTouch, { once: true });
                                });
                            }
                        }
                    };

                    // 트랜시버 추가
                    this.pc.addTransceiver('video', { direction: 'recvonly' });
                    this.pc.addTransceiver('audio', { direction: 'recvonly' });

                    // Offer 생성
                    const offer = await this.pc.createOffer({
                        offerToReceiveAudio: true,
                        offerToReceiveVideo: true
                    });
                    
                    await this.pc.setLocalDescription(offer);

                    // WHEP 요청
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000);

                    const response = await fetch('https://returnfeed.net/pgm_srt_raw/whep', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/sdp',
                        },
                        body: offer.sdp,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`WHEP 요청 실패: ${response.status}`);
                    }

                    const answerSdp = await response.text();
                    
                    await this.pc.setRemoteDescription({
                        type: 'answer',
                        sdp: answerSdp
                    });

                    console.log('WebRTC 연결 설정 완료');

                } catch (error) {
                    console.error('WebRTC 연결 실패:', error);
                    this.updateConnectionStatus(false);
                    document.getElementById('loadingSpinner').style.display = 'none';
                    document.getElementById('statusIndicator').textContent = '연결 실패';
                }
            }

            async reconnectWebRTC() {
                console.log('WebRTC 재연결 시도');
                if (this.pc) {
                    this.pc.close();
                }
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.startWebRTC();
            }

            reconnectIfNeeded() {
                if (this.ws && this.ws.readyState !== WebSocket.OPEN) {
                    this.connectWebSocket();
                }
                if (this.pc && this.pc.connectionState === 'failed') {
                    this.reconnectWebRTC();
                }
            }

            async reconnectAll() {
                console.log('전체 재연결 시도');
                await Promise.all([
                    this.connectWebSocket(),
                    this.reconnectWebRTC()
                ]);
            }

            startStatsMonitoring() {
                setInterval(async () => {
                    if (this.pc && this.pc.getStats) {
                        try {
                            const stats = await this.pc.getStats();
                            let rtt = 'N/A', bitrate = 'N/A';
                            
                            stats.forEach(report => {
                                if (report.type === 'remote-candidate' && report.currentRoundTripTime) {
                                    rtt = (report.currentRoundTripTime * 1000).toFixed(0) + 'ms';
                                }
                                if (report.type === 'inbound-rtp' && report.kind === 'video') {
                                    const now = Date.now();
                                    if (this.lastTallyState.lastTimestamp > 0) {
                                        const bps = 8 * (report.bytesReceived - this.lastTallyState.lastBytesReceived) / 
                                                   (now - this.lastTallyState.lastTimestamp);
                                        bitrate = bps.toFixed(1) + 'kbps';
                                    }
                                    this.lastTallyState.lastBytesReceived = report.bytesReceived;
                                    this.lastTallyState.lastTimestamp = now;
                                }
                            });
                            
                            this.streamStats = { rtt, bitrate };
                            document.getElementById('rttCounter').textContent = rtt;
                            document.getElementById('bitrateCounter').textContent = bitrate;
                        } catch (e) {
                            console.error('통계 수집 실패:', e);
                        }
                    }
                }, 2000);
            }

            toggleOverlay() {
                this.isOverlayVisible = !this.isOverlayVisible;
                
                const overlayControls = document.getElementById('overlayControls');
                const camTitle = document.getElementById('camTitle');
                const performanceMonitor = document.getElementById('performanceMonitor');

                if (this.isOverlayVisible) {
                    overlayControls.classList.add('visible');
                    camTitle.classList.add('visible');
                    
                    if (this.settings.performance) {
                        performanceMonitor.classList.add('visible');
                    }
                    
                    // 3초 후 자동 숨김
                    if (this.overlayTimeout) {
                        clearTimeout(this.overlayTimeout);
                    }
                    this.overlayTimeout = setTimeout(() => {
                        this.hideOverlay();
                    }, 3000);
                } else {
                    this.hideOverlay();
                }
            }

            hideOverlay() {
                this.isOverlayVisible = false;
                
                document.getElementById('overlayControls').classList.remove('visible');
                document.getElementById('camTitle').classList.remove('visible');
                document.getElementById('performanceMonitor').classList.remove('visible');
                
                if (this.overlayTimeout) {
                    clearTimeout(this.overlayTimeout);
                    this.overlayTimeout = null;
                }
            }

            handleSettingToggle(settingId, checked) {
                switch (settingId) {
                    case 'vibrationToggle':
                        this.settings.vibration = checked;
                        break;
                    case 'audioToggle':
                        this.settings.audio = checked;
                        break;
                    case 'conserveToggle':
                        this.settings.mode = checked ? 'conserve' : 'normal';
                        break;
                    case 'performanceToggle':
                        this.settings.performance = checked;
                        const monitor = document.getElementById('performanceMonitor');
                        if (checked && this.isOverlayVisible) {
                            monitor.classList.add('visible');
                        } else {
                            monitor.classList.remove('visible');
                        }
                        break;
                }
                
                this.saveSettings();
            }

            updateSettingsUI() {
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
                document.getElementById('audioToggle').checked = this.settings.audio;
                document.getElementById('conserveToggle').checked = this.settings.mode === 'conserve';
                document.getElementById('performanceToggle').checked = this.settings.performance || false;
            }

            updateConnectionStatus(status) {
                const statusDot = document.getElementById('statusDot');
                const connectionText = document.getElementById('connectionText');
                
                statusDot.className = 'status-dot';
                
                if (status === true) {
                    statusDot.classList.add('connected');
                    connectionText.textContent = '연결됨';
                } else if (status === 'connecting') {
                    statusDot.classList.add('connecting');
                    connectionText.textContent = '연결 중...';
                } else {
                    connectionText.textContent = '연결 실패';
                }
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('returnfeed_settings_v2');
                    return saved ? JSON.parse(saved) : { 
                        vibration: true, 
                        audio: true, 
                        mode: 'normal',
                        performance: false
                    };
                } catch {
                    return { 
                        vibration: true, 
                        audio: true, 
                        mode: 'normal',
                        performance: false
                    };
                }
            }

            saveSettings() {
                try {
                    localStorage.setItem('returnfeed_settings_v2', JSON.stringify(this.settings));
                } catch (error) {
                    console.error('설정 저장 실패:', error);
                }
            }
        }

        // 앱 시작
        document.addEventListener('DOMContentLoaded', () => {
            new ReturnFeedApp();
        });

        // 서비스 워커 등록 (오프라인 지원)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(err => {
                console.log('Service Worker 등록 실패:', err);
            });
        }
    </script>
</body>
</html>

