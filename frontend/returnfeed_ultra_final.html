<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ReturnFeed Live</title>
    
    <!-- 폰트 로드 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gmarket+Sans+TTF:wght@500;700&display=swap" rel="stylesheet">
    
    <!-- HLS.js 라이브러리 (Fallback용) -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    
    <style>
        :root {
            --color-pvw: #00A36C;
            --color-pgm: #D41728;
            --tally-border-width: 20px; /* 2배로 확대 */
            --color-blue: #00c6ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Gmarket Sans TTF', sans-serif;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* 스플래시 화면 */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .logo-container {
            animation: pulse 2s infinite;
        }

        .logo-text {
            font-family: 'Gmarket Sans TTF', sans-serif;
            font-size: 32px;
            font-weight: 700;
            fill: white;
        }

        .logo-text .feed {
            fill: var(--color-blue);
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.8; 
                transform: scale(1.05);
            }
        }

        /* 설정 화면 */
        .setup-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            text-align: center;
        }

        .setup-screen.active {
            display: flex;
        }

        .setup-logo {
            margin-bottom: 2rem;
        }

        .setup-status {
            font-size: 1.125rem;
            color: #9ca3af;
            margin-bottom: 2rem;
            height: 1.75rem;
            transition: opacity 0.3s ease;
        }

        .setup-form {
            width: 100%;
            max-width: 24rem;
            transition: all 0.5s ease;
            opacity: 0;
            transform: translateY(-1rem);
        }

        .setup-form.ready {
            opacity: 1;
            transform: translateY(0);
        }

        .setup-label {
            display: block;
            text-align: left;
            font-size: 1.125rem;
            font-weight: 500;
            color: #e5e7eb;
            margin-bottom: 0.75rem;
        }

        .setup-select {
            background: #374151;
            border: 2px solid #4b5563;
            color: white;
            font-size: 1.25rem;
            border-radius: 0.5rem;
            width: 100%;
            padding: 1rem;
            appearance: none;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .setup-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .setup-select option {
            background: #374151;
            color: white;
            padding: 0.5rem;
        }

        /* 플레이어 화면 */
        .player-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            display: none;
        }

        .player-screen.active {
            display: block;
        }

        /* 비디오 컨테이너 */
        .video-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000000;
            overflow: hidden;
        }

        .video-element {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #000000;
        }

        /* 탈리 오버레이 - 2배 확대 */
        .tally-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            transition: box-shadow 0.05s ease-in-out; /* 극도로 빠른 반응 */
        }

        .tally-container.pgm-tally {
            box-shadow: 0 0 0 var(--tally-border-width) var(--color-pgm) inset;
        }

        .tally-container.pvw-tally {
            box-shadow: 0 0 0 var(--tally-border-width) var(--color-pvw) inset;
        }

        .tally-container.flash-pgm {
            animation: flash-pgm-anim 0.1s ease-out; /* 극도로 빠른 애니메이션 */
        }

        .tally-container.flash-pvw {
            animation: flash-pvw-anim 0.1s ease-out; /* 극도로 빠른 애니메이션 */
        }

        @keyframes flash-pgm-anim {
            0% { 
                box-shadow: 0 0 0 var(--tally-border-width) #ff7979 inset; 
            }
            100% { 
                box-shadow: 0 0 0 var(--tally-border-width) var(--color-pgm) inset; 
            }
        }

        @keyframes flash-pvw-anim {
            0% { 
                box-shadow: 0 0 0 var(--tally-border-width) #2ecc71 inset; 
            }
            100% { 
                box-shadow: 0 0 0 var(--tally-border-width) var(--color-pvw) inset; 
            }
        }

        /* CAM 타이틀 */
        .cam-title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Gmarket Sans TTF', sans-serif;
            font-size: clamp(4rem, 15vw, 12rem);
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 
                0 0 30px rgba(0, 0, 0, 0.8),
                0 4px 15px rgba(0, 0, 0, 0.6);
            z-index: 15;
            opacity: 0;
            transition: all 0.4s ease;
            pointer-events: none;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .cam-title.visible {
            opacity: 1;
        }

        /* 오버레이 컨트롤 */
        .overlay-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.6) 70%, rgba(0,0,0,0) 100%);
            padding: 3rem 1.5rem 1.5rem;
            z-index: 30;
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.4s ease;
            backdrop-filter: blur(10px);
        }

        .overlay-controls.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* 설정 그리드 */
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 0.75rem;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
        }

        .setting-item:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .setting-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
        }

        /* 토글 스위치 */
        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #4a5568;
            transition: 0.4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #38a169;
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        /* 상태 표시 */
        .status-bar {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1.5rem;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 25;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
            animation: pulse-dot 2s infinite;
        }

        .status-dot.connected {
            background: #10b981;
        }

        .status-dot.connecting {
            background: #f59e0b;
        }

        @keyframes pulse-dot {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.6; 
                transform: scale(1.1);
            }
        }

        /* 성능 모니터 */
        .performance-monitor {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.8);
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            font-size: 0.7rem;
            color: #9ca3af;
            z-index: 25;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 500;
        }

        .performance-monitor.visible {
            opacity: 1;
        }

        .performance-monitor div {
            margin-bottom: 0.25rem;
        }

        .performance-monitor div:last-child {
            margin-bottom: 0;
        }

        /* 터치 영역 */
        .touch-area {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 5;
            cursor: pointer;
        }

        /* 로딩 스피너 */
        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top: 3px solid var(--color-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 15;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* 음성 디버그 표시 */
        .voice-debug {
            position: absolute;
            top: 4rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.9);
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.7rem;
            color: #10b981;
            z-index: 25;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(16, 185, 129, 0.3);
            font-weight: 500;
        }

        .voice-debug.visible {
            opacity: 1;
        }

        /* 모바일 재생 버튼 */
        .mobile-play-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 198, 255, 0.9);
            border: none;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            z-index: 20;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .mobile-play-button:hover {
            background: rgba(0, 198, 255, 1);
            transform: translate(-50%, -50%) scale(1.1);
        }

        .mobile-play-button.visible {
            display: flex;
        }

        /* 연결 상태 메시지 */
        .connection-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 0.9rem;
            color: #f59e0b;
            z-index: 20;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(245, 158, 11, 0.3);
            text-align: center;
            max-width: 80%;
        }

        .connection-message.visible {
            opacity: 1;
        }

        /* 반응형 디자인 */
        @media (max-width: 768px) {
            :root {
                --tally-border-width: 16px; /* 모바일에서도 2배 */
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }
            
            .overlay-controls {
                padding: 2.5rem 1rem 1rem;
            }
            
            .status-bar {
                top: 0.75rem;
                right: 0.75rem;
                padding: 0.4rem 0.8rem;
                font-size: 0.75rem;
            }
            
            .performance-monitor {
                bottom: 0.75rem;
                left: 0.75rem;
                padding: 0.6rem 0.8rem;
                font-size: 0.65rem;
            }

            .voice-debug {
                top: 3rem;
                right: 0.75rem;
                padding: 0.4rem 0.6rem;
                font-size: 0.65rem;
            }
        }

        @media (max-width: 480px) {
            .setup-screen {
                padding: 1.5rem;
            }
            
            .setup-select {
                font-size: 1.1rem;
                padding: 0.9rem;
            }
            
            .setting-item {
                padding: 0.9rem 1rem;
            }
            
            .setting-label {
                font-size: 0.85rem;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .overlay-controls {
                padding: 2rem 1rem 0.75rem;
            }
            
            .cam-title {
                font-size: clamp(3rem, 12vw, 8rem);
            }
        }

        /* 다크 모드 최적화 */
        @media (prefers-color-scheme: dark) {
            .setup-screen {
                background: #0a0a0a;
            }
        }

        /* 고대비 모드 지원 */
        @media (prefers-contrast: high) {
            .setting-item {
                border-width: 2px;
            }
            
            .status-bar {
                border-width: 2px;
            }
        }

        /* 애니메이션 감소 모드 */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* 터치 디바이스 최적화 */
        @media (hover: none) and (pointer: coarse) {
            .setting-item:hover {
                transform: none;
                background: rgba(255, 255, 255, 0.08);
            }
        }
    </style>
</head>
<body>
    <!-- 스플래시 화면 -->
    <div class="splash-screen" id="splashScreen">
        <div class="logo-container">
            <svg width="200" height="50" viewBox="0 0 200 50">
                <text x="0" y="35" class="logo-text">
                    Return<tspan class="feed">Feed</tspan>
                </text>
            </svg>
        </div>
    </div>

    <!-- 설정 화면 -->
    <div class="setup-screen" id="setupScreen">
        <div class="setup-logo">
            <svg width="200" height="50" viewBox="0 0 200 50">
                <text x="0" y="35" class="logo-text">
                    Return<tspan class="feed">Feed</tspan>
                </text>
            </svg>
        </div>
        <p class="setup-status" id="setupStatus">서버에 연결하는 중...</p>
        <div class="setup-form" id="setupForm">
            <label for="cameraSelect" class="setup-label">카메라 선택</label>
            <select id="cameraSelect" class="setup-select">
                <option value="" disabled selected>담당할 카메라를 선택하세요</option>
                <option value="1:CAM 1">CAM 1: 3루캠.mp4</option>
                <option value="2:CAM 2">CAM 2: 배터리샷.mp4</option>
                <option value="3:CAM 3">CAM 3: 볼트래킹.mp4</option>
                <option value="4:CAM 4">CAM 4: 심판캠.mp4</option>
                <option value="5:CAM 5">CAM 5: 리플레이저장 연습용</option>
                <option value="6:CAM 6">CAM 6: 리플레이저장 연습용</option>
                <option value="0:PGM Only" class="border-t">---</option>
                <option value="0:PGM Only">PGM만 보기 (Tally 기능 OFF)</option>
            </select>
        </div>
    </div>

    <!-- 플레이어 화면 -->
    <div class="player-screen" id="playerScreen">
        <!-- 비디오 컨테이너 -->
        <div class="video-container">
            <video class="video-element" id="videoElement" autoplay muted playsinline webkit-playsinline x-webkit-airplay="allow"></video>
            <div class="tally-container" id="tallyContainer"></div>
            <div class="loading-spinner" id="loadingSpinner" style="display: none;"></div>
            <button class="mobile-play-button" id="mobilePlayButton">▶</button>
            <div class="connection-message" id="connectionMessage">연결을 시도하고 있습니다...</div>
        </div>

        <!-- CAM 타이틀 -->
        <div class="cam-title" id="camTitle">CAM 1</div>

        <!-- 상태 표시 -->
        <div class="status-bar">
            <div class="status-dot" id="statusDot"></div>
            <span id="connectionText">연결 중...</span>
        </div>

        <!-- 음성 디버그 표시 -->
        <div class="voice-debug" id="voiceDebug">음성: 대기 중</div>

        <!-- 성능 모니터 -->
        <div class="performance-monitor" id="performanceMonitor">
            <div>RTT: <span id="rttCounter">N/A</span></div>
            <div>Bitrate: <span id="bitrateCounter">N/A</span></div>
            <div>상태: <span id="statusIndicator">연결 중</span></div>
        </div>

        <!-- 오버레이 컨트롤 -->
        <div class="overlay-controls" id="overlayControls">
            <!-- 설정 그리드 -->
            <div class="settings-grid">
                <div class="setting-item">
                    <span class="setting-label">진동</span>
                    <label class="switch">
                        <input type="checkbox" id="vibrationToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <span class="setting-label">음성안내</span>
                    <label class="switch">
                        <input type="checkbox" id="audioToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <span class="setting-label">절약모드</span>
                    <label class="switch">
                        <input type="checkbox" id="conserveToggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <span class="setting-label">성능표시</span>
                    <label class="switch">
                        <input type="checkbox" id="performanceToggle">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
        </div>

        <!-- 터치 영역 -->
        <div class="touch-area" id="touchArea"></div>
    </div>

    <script>
        // 모바일 디바이스 감지
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

        // 극강 남성 음성 시스템 (완전 재구축 - 여성 음성 완전 차단)
        class UltraForcedMaleAudioSystem {
            constructor() {
                this.isInitialized = false;
                this.currentUtterance = null;
                this.maleVoices = [];
                this.selectedVoice = null;
                this.isProcessing = false;
                this.debugElement = null;
                this.lastCommand = null;
                this.commandQueue = [];
                this.isQueueProcessing = false;
                this.audioContext = null;
                this.userInteracted = false;
                this.voiceLoadAttempts = 0;
                this.maxVoiceLoadAttempts = 20;
                this.forceReloadTimer = null;
                
                this.init();
            }

            async init() {
                this.debugElement = document.getElementById('voiceDebug');
                await this.initializeAudioContext();
                await this.aggressiveVoiceInitialization();
                this.setupVoiceChangeListener();
                this.startPeriodicVoiceCheck();
                this.isInitialized = true;
                this.updateDebug('극강 남성 시스템 준비됨');
            }

            async initializeAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('오디오 컨텍스트 초기화됨');
                } catch (error) {
                    console.error('오디오 컨텍스트 생성 실패:', error);
                }
            }

            async aggressiveVoiceInitialization() {
                if (!('speechSynthesis' in window)) {
                    console.error('음성 합성을 지원하지 않는 브라우저입니다.');
                    this.updateDebug('음성 지원 안함');
                    return;
                }

                // 극도로 공격적인 음성 로드 시도
                await this.forceLoadVoices();
                this.loadMaleVoices();
                this.selectBestMaleVoice();
                
                // 음성이 로드되지 않았으면 계속 시도
                if (this.maleVoices.length === 0 && this.voiceLoadAttempts < this.maxVoiceLoadAttempts) {
                    this.voiceLoadAttempts++;
                    console.log(`음성 로드 재시도 ${this.voiceLoadAttempts}/${this.maxVoiceLoadAttempts}`);
                    setTimeout(() => this.aggressiveVoiceInitialization(), 500);
                }
            }

            forceLoadVoices() {
                return new Promise((resolve) => {
                    // 1단계: 기본 음성 로드 확인
                    let voices = speechSynthesis.getVoices();
                    if (voices.length > 0) {
                        console.log('음성 목록 즉시 로드됨:', voices.length);
                        resolve();
                        return;
                    }

                    // 2단계: 강제 음성 로드 시도
                    const forceLoad = () => {
                        // 더미 음성 생성으로 강제 로드
                        const utterance = new SpeechSynthesisUtterance('');
                        utterance.volume = 0;
                        speechSynthesis.speak(utterance);
                        speechSynthesis.cancel();
                        
                        voices = speechSynthesis.getVoices();
                        if (voices.length > 0) {
                            console.log('강제 로드 성공:', voices.length);
                            resolve();
                            return true;
                        }
                        return false;
                    };

                    // 3단계: voiceschanged 이벤트 대기
                    let attempts = 0;
                    const maxAttempts = 50; // 25초 대기
                    
                    const checkVoices = () => {
                        attempts++;
                        
                        if (forceLoad()) {
                            speechSynthesis.removeEventListener('voiceschanged', checkVoices);
                            resolve();
                            return;
                        }
                        
                        if (attempts >= maxAttempts) {
                            speechSynthesis.removeEventListener('voiceschanged', checkVoices);
                            console.warn('음성 로드 타임아웃');
                            resolve();
                        }
                    };

                    speechSynthesis.addEventListener('voiceschanged', checkVoices);
                    
                    // 4단계: 주기적 강제 로드 시도
                    const forceInterval = setInterval(() => {
                        if (forceLoad()) {
                            clearInterval(forceInterval);
                            speechSynthesis.removeEventListener('voiceschanged', checkVoices);
                            resolve();
                        }
                    }, 100);
                    
                    // 5단계: 최종 타임아웃
                    setTimeout(() => {
                        clearInterval(forceInterval);
                        speechSynthesis.removeEventListener('voiceschanged', checkVoices);
                        resolve();
                    }, 25000);
                    
                    // 즉시 첫 번째 시도
                    forceLoad();
                });
            }

            setupVoiceChangeListener() {
                speechSynthesis.addEventListener('voiceschanged', () => {
                    console.log('음성 목록 변경 감지됨');
                    this.loadMaleVoices();
                    this.selectBestMaleVoice();
                });
            }

            startPeriodicVoiceCheck() {
                // 5초마다 음성 목록 재확인 (모바일 환경 대응)
                setInterval(() => {
                    const currentVoices = speechSynthesis.getVoices();
                    if (currentVoices.length > this.maleVoices.length) {
                        console.log('새로운 음성 발견됨, 재로드');
                        this.loadMaleVoices();
                        this.selectBestMaleVoice();
                    }
                }, 5000);
            }

            loadMaleVoices() {
                const allVoices = speechSynthesis.getVoices();
                console.log('전체 음성 목록 (극강 필터링):', allVoices.map(v => 
                    `${v.name} (${v.lang}) - ${v.gender || 'unknown'} - ${v.localService ? 'local' : 'remote'}`
                ));

                // 극강 남성 음성 키워드 (우선순위 순) - 여성 음성 완전 차단
                const ultraMaleKeywords = [
                    // iOS 남성 음성 (최고 우선순위)
                    { keyword: 'alex', priority: 1, reason: 'ios-alex-primary', confidence: 100 },
                    { keyword: 'daniel', priority: 2, reason: 'ios-daniel', confidence: 95 },
                    { keyword: 'fred', priority: 3, reason: 'ios-fred', confidence: 90 },
                    { keyword: 'jorge', priority: 4, reason: 'ios-jorge', confidence: 85 },
                    { keyword: 'aaron', priority: 5, reason: 'ios-aaron', confidence: 80 },
                    
                    // Android 남성 음성 (높은 우선순위)
                    { keyword: 'google uk english male', priority: 6, reason: 'android-male-primary', confidence: 95 },
                    { keyword: 'google us english male', priority: 7, reason: 'android-male-us', confidence: 90 },
                    { keyword: 'microsoft david', priority: 8, reason: 'windows-david', confidence: 85 },
                    { keyword: 'microsoft mark', priority: 9, reason: 'windows-mark', confidence: 80 },
                    
                    // 명시적 남성 표시 (중간 우선순위)
                    { keyword: 'male', priority: 15, reason: 'explicit-male', confidence: 70 },
                    { keyword: 'man', priority: 16, reason: 'explicit-man', confidence: 65 },
                    { keyword: 'masculine', priority: 17, reason: 'explicit-masculine', confidence: 60 },
                    
                    // 확실한 남성 이름들 (낮은 우선순위)
                    { keyword: 'tom', priority: 25, reason: 'male-name-tom', confidence: 50 },
                    { keyword: 'bruce', priority: 26, reason: 'male-name-bruce', confidence: 50 },
                    { keyword: 'ralph', priority: 27, reason: 'male-name-ralph', confidence: 50 },
                    { keyword: 'nathan', priority: 28, reason: 'male-name-nathan', confidence: 50 },
                    { keyword: 'david', priority: 29, reason: 'male-name-david', confidence: 50 },
                    { keyword: 'mark', priority: 30, reason: 'male-name-mark', confidence: 50 },
                    { keyword: 'john', priority: 31, reason: 'male-name-john', confidence: 50 },
                    { keyword: 'mike', priority: 32, reason: 'male-name-mike', confidence: 50 },
                    { keyword: 'james', priority: 33, reason: 'male-name-james', confidence: 50 },
                    { keyword: 'robert', priority: 34, reason: 'male-name-robert', confidence: 50 },
                    { keyword: 'william', priority: 35, reason: 'male-name-william', confidence: 50 },
                    { keyword: 'richard', priority: 36, reason: 'male-name-richard', confidence: 50 },
                    { keyword: 'charles', priority: 37, reason: 'male-name-charles', confidence: 50 },
                    { keyword: 'joseph', priority: 38, reason: 'male-name-joseph', confidence: 50 }
                ];

                // 여성 음성 차단 키워드 (완전 제외)
                const femaleBlockKeywords = [
                    'female', 'woman', 'feminine', 'girl', 'lady',
                    'samantha', 'victoria', 'allison', 'ava', 'susan',
                    'karen', 'moira', 'tessa', 'veena', 'rishi',
                    'kyoko', 'mei-jia', 'sin-ji', 'ting-ting',
                    'google uk english female', 'google us english female',
                    'microsoft zira', 'microsoft hazel'
                ];

                this.maleVoices = [];

                // 1단계: 명시적으로 남성으로 표시된 음성 (최우선)
                allVoices.forEach(voice => {
                    if (voice.gender === 'male' || voice.gender === 'masculine') {
                        // 여성 키워드 체크
                        const voiceName = voice.name.toLowerCase();
                        const isFemale = femaleBlockKeywords.some(keyword => 
                            voiceName.includes(keyword.toLowerCase())
                        );
                        
                        if (!isFemale) {
                            this.maleVoices.push({ 
                                voice, 
                                priority: 0, 
                                reason: 'gender-male',
                                confidence: 100
                            });
                        }
                    }
                });

                // 2단계: 키워드 기반 매칭 (여성 음성 완전 차단)
                ultraMaleKeywords.forEach(({ keyword, priority, reason, confidence }) => {
                    allVoices.forEach(voice => {
                        const voiceName = voice.name.toLowerCase();
                        
                        // 여성 키워드 체크 (완전 차단)
                        const isFemale = femaleBlockKeywords.some(blockKeyword => 
                            voiceName.includes(blockKeyword.toLowerCase())
                        );
                        
                        if (!isFemale && 
                            voiceName.includes(keyword.toLowerCase()) && 
                            !this.maleVoices.some(mv => mv.voice.name === voice.name)) {
                            this.maleVoices.push({ 
                                voice, 
                                priority, 
                                reason,
                                confidence
                            });
                        }
                    });
                });

                // 3단계: 모바일 전용 패턴 매칭 (극강 필터링)
                const mobilePatterns = [
                    { pattern: /^Alex$/i, priority: 1, reason: 'ios-alex-exact', confidence: 100 },
                    { pattern: /^Daniel$/i, priority: 2, reason: 'ios-daniel-exact', confidence: 95 },
                    { pattern: /^Google UK English Male$/i, priority: 6, reason: 'android-male-exact', confidence: 95 },
                    { pattern: /^Microsoft David$/i, priority: 8, reason: 'windows-david-exact', confidence: 85 },
                    { pattern: /^Microsoft Mark$/i, priority: 9, reason: 'windows-mark-exact', confidence: 80 }
                ];

                mobilePatterns.forEach(({ pattern, priority, reason, confidence }) => {
                    allVoices.forEach(voice => {
                        if (pattern.test(voice.name) && 
                            !this.maleVoices.some(mv => mv.voice.name === voice.name)) {
                            
                            // 여성 키워드 이중 체크
                            const voiceName = voice.name.toLowerCase();
                            const isFemale = femaleBlockKeywords.some(keyword => 
                                voiceName.includes(keyword.toLowerCase())
                            );
                            
                            if (!isFemale) {
                                this.maleVoices.push({ 
                                    voice, 
                                    priority, 
                                    reason,
                                    confidence
                                });
                            }
                        }
                    });
                });

                // 4단계: 영어 음성 중 안전한 것들만 (최후의 수단)
                allVoices.forEach(voice => {
                    if (voice.lang.startsWith('en') && 
                        !this.maleVoices.some(mv => mv.voice.name === voice.name)) {
                        
                        const voiceName = voice.name.toLowerCase();
                        
                        // 여성 키워드 완전 차단
                        const isFemale = femaleBlockKeywords.some(keyword => 
                            voiceName.includes(keyword.toLowerCase())
                        );
                        
                        // 중성적이거나 불분명한 음성만 허용 (여성 음성 완전 차단)
                        if (!isFemale) {
                            this.maleVoices.push({ 
                                voice, 
                                priority: 100, 
                                reason: 'english-safe-fallback',
                                confidence: 30
                            });
                        }
                    }
                });

                // 우선순위와 신뢰도로 정렬
                this.maleVoices.sort((a, b) => {
                    if (a.priority !== b.priority) {
                        return a.priority - b.priority;
                    }
                    return b.confidence - a.confidence;
                });

                console.log('극강 남성 음성 후보 (여성 완전 차단):', this.maleVoices.map(mv => 
                    `${mv.voice.name} (우선순위: ${mv.priority}, 신뢰도: ${mv.confidence}%, 이유: ${mv.reason})`
                ));
            }

            selectBestMaleVoice() {
                if (this.maleVoices.length === 0) {
                    // 남성 음성이 없으면 첫 번째 음성 사용 (최후의 수단)
                    const allVoices = speechSynthesis.getVoices();
                    this.selectedVoice = allVoices[0] || null;
                    this.updateDebug(`기본음성: ${this.selectedVoice?.name || '없음'} (경고)`);
                    console.warn('남성 음성을 찾을 수 없어 기본 음성 사용');
                } else {
                    this.selectedVoice = this.maleVoices[0].voice;
                    this.updateDebug(`극강남성: ${this.selectedVoice.name} (${this.maleVoices[0].confidence}%)`);
                    console.log('선택된 극강 남성 음성:', {
                        name: this.selectedVoice.name,
                        lang: this.selectedVoice.lang,
                        gender: this.selectedVoice.gender || 'unknown',
                        confidence: this.maleVoices[0].confidence,
                        reason: this.maleVoices[0].reason
                    });
                }
            }

            // 완전 재구축된 음성 재생 시스템 (중복 완전 방지 + 마지막 명령 우선)
            speak(text, priority = 'normal') {
                if (!this.isInitialized || !this.selectedVoice) {
                    console.warn('극강 남성 음성 시스템이 초기화되지 않았습니다.');
                    return;
                }

                // 극강 중복 방지: 같은 명령이 100ms 내에 들어오면 무시
                const now = Date.now();
                if (this.lastCommand && 
                    this.lastCommand.text === text && 
                    (now - this.lastCommand.timestamp) < 100) {
                    console.log(`극강 중복 방지: ${text} (${now - this.lastCommand.timestamp}ms 간격)`);
                    return;
                }

                // 명령 기록 업데이트
                this.lastCommand = { text, timestamp: now };

                // 즉시 기존 음성 완전 중단 (마지막 명령 절대 우선)
                this.forceStopCurrentSpeech();

                // 큐 완전 클리어 (마지막 명령만 실행)
                this.commandQueue = [];

                // 새 명령을 큐에 추가
                this.commandQueue.push({ text, priority, timestamp: now });

                // 큐 처리 즉시 시작
                this.processQueue();
            }

            async processQueue() {
                if (this.isQueueProcessing || this.commandQueue.length === 0) {
                    return;
                }

                this.isQueueProcessing = true;

                while (this.commandQueue.length > 0) {
                    const command = this.commandQueue.shift();
                    await this.executeUltraMaleVoiceCommand(command.text);
                    
                    // 명령 간 최소 간격 (25ms)
                    await new Promise(resolve => setTimeout(resolve, 25));
                }

                this.isQueueProcessing = false;
            }

            executeUltraMaleVoiceCommand(text) {
                return new Promise((resolve) => {
                    // 새 음성 생성
                    const utterance = new SpeechSynthesisUtterance(text);
                    this.currentUtterance = utterance;

                    // 선택된 극강 남성 음성 적용
                    utterance.voice = this.selectedVoice;

                    // 극도로 남성적인 음성 설정 (극강 모드)
                    utterance.rate = isMobile ? 0.8 : 0.95;       // 모바일에서 더 느리게 (명확성)
                    utterance.pitch = 0.05;                      // 극도로 낮은 피치 (극강 남성)
                    utterance.volume = 1.0;                      // 최대 볼륨

                    // 이벤트 핸들러
                    utterance.onstart = () => {
                        this.isProcessing = true;
                        this.updateDebug(`극강남성재생: ${text}`);
                        console.log(`극강 남성 음성 재생 시작: ${text} (음성: ${this.selectedVoice.name}, 피치: 0.05)`);
                    };

                    utterance.onend = () => {
                        this.isProcessing = false;
                        this.currentUtterance = null;
                        this.updateDebug('재생 완료');
                        console.log(`극강 남성 음성 재생 완료: ${text}`);
                        resolve();
                    };

                    utterance.onerror = (event) => {
                        this.isProcessing = false;
                        this.currentUtterance = null;
                        this.updateDebug(`오류: ${event.error}`);
                        console.error('극강 남성 음성 재생 오류:', event.error);
                        
                        // 오류 시 대체 음성 시도
                        if (this.maleVoices.length > 1) {
                            console.log('대체 남성 음성으로 재시도');
                            this.selectedVoice = this.maleVoices[1].voice;
                            setTimeout(() => this.speak(text), 100);
                        }
                        
                        resolve();
                    };

                    // 즉시 재생
                    try {
                        speechSynthesis.speak(utterance);
                        console.log(`극강 남성 음성 명령 실행: ${text} (음성: ${this.selectedVoice.name}, 피치: 0.05, 속도: ${utterance.rate})`);
                    } catch (error) {
                        console.error('극강 남성 음성 재생 실패:', error);
                        this.updateDebug(`실패: ${error.message}`);
                        resolve();
                    }
                });
            }

            forceStopCurrentSpeech() {
                // 극강 음성 중단
                if (speechSynthesis.speaking || speechSynthesis.pending) {
                    speechSynthesis.cancel();
                    console.log('기존 음성 강제 중단됨');
                }
                
                // 추가 중단 시도 (모바일 환경 대응)
                setTimeout(() => {
                    if (speechSynthesis.speaking) {
                        speechSynthesis.cancel();
                        console.log('음성 중단 재시도');
                    }
                }, 10);
                
                this.currentUtterance = null;
                this.isProcessing = false;
            }

            updateDebug(message) {
                if (this.debugElement) {
                    this.debugElement.textContent = `음성: ${message}`;
                    this.debugElement.classList.add('visible');
                    
                    // 5초 후 숨김 (더 오래 표시)
                    setTimeout(() => {
                        this.debugElement.classList.remove('visible');
                    }, 5000);
                }
            }

            // 사용자 상호작용 설정
            setUserInteracted() {
                this.userInteracted = true;
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                console.log('극강 남성 음성 시스템 사용자 상호작용 설정됨');
            }

            // 테스트 메서드
            testVoice(text = 'Test Male Voice') {
                this.speak(text);
            }

            // 음성 목록 가져오기
            getAvailableVoices() {
                return speechSynthesis.getVoices();
            }

            // 현재 선택된 음성 정보
            getCurrentVoiceInfo() {
                return this.selectedVoice ? {
                    name: this.selectedVoice.name,
                    lang: this.selectedVoice.lang,
                    gender: this.selectedVoice.gender || 'unknown',
                    confidence: this.maleVoices.find(mv => mv.voice.name === this.selectedVoice.name)?.confidence || 0
                } : null;
            }

            // 강제 음성 재로드
            forceReloadVoices() {
                console.log('음성 목록 강제 재로드');
                this.voiceLoadAttempts = 0;
                this.aggressiveVoiceInitialization();
            }
        }

        // 모바일 최적화 WebRTC 시스템 (완전 재구축)
        class UltraMobileWebRTCSystem {
            constructor() {
                this.pc = null;
                this.isConnecting = false;
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.connectionTimeout = null;
                this.statsInterval = null;
                this.lastStats = { bytesReceived: 0, timestamp: 0 };
                this.fallbackMode = false;
                this.userInteracted = false;
                this.connectionStartTime = 0;
                
                this.init();
            }

            async init() {
                console.log('모바일 최적화 WebRTC 시스템 초기화');
                this.setupUserInteractionDetection();
            }

            setupUserInteractionDetection() {
                const events = ['touchstart', 'touchend', 'click', 'keydown'];
                
                const handleUserInteraction = () => {
                    this.userInteracted = true;
                    console.log('사용자 상호작용 감지됨');
                    
                    // 이벤트 리스너 제거
                    events.forEach(event => {
                        document.removeEventListener(event, handleUserInteraction);
                    });
                };

                events.forEach(event => {
                    document.addEventListener(event, handleUserInteraction, { once: true });
                });
            }

            async startConnection() {
                if (this.isConnecting || this.isConnected) {
                    console.log('이미 연결 중이거나 연결됨');
                    return;
                }

                this.connectionStartTime = Date.now();
                this.isConnecting = true;
                this.updateConnectionStatus('connecting');
                this.showLoadingSpinner(true);
                this.showConnectionMessage('WebRTC 연결을 시도하고 있습니다...');

                try {
                    await this.initializeWebRTC();
                    await this.createOffer();
                    await this.sendWhepRequest();
                    
                    console.log('WebRTC 연결 설정 완료');
                    
                } catch (error) {
                    console.error('WebRTC 연결 실패:', error);
                    this.handleConnectionError(error);
                }
            }

            async initializeWebRTC() {
                if (this.pc) {
                    this.pc.close();
                }

                // 모바일 최적화 WebRTC 설정 (강화)
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' },
                        { urls: 'stun:stun4.l.google.com:19302' },
                        { urls: 'stun:stun.services.mozilla.com' },
                        { urls: 'stun:stun.ekiga.net' }
                    ],
                    iceCandidatePoolSize: 10,
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                    iceTransportPolicy: 'all',
                    sdpSemantics: 'unified-plan'
                };

                this.pc = new RTCPeerConnection(configuration);

                // 연결 상태 모니터링 (강화)
                this.pc.onconnectionstatechange = () => {
                    const connectionTime = Date.now() - this.connectionStartTime;
                    console.log(`WebRTC 연결 상태: ${this.pc.connectionState} (${connectionTime}ms)`);
                    this.handleConnectionStateChange(this.pc.connectionState);
                };

                this.pc.oniceconnectionstatechange = () => {
                    console.log('ICE 연결 상태:', this.pc.iceConnectionState);
                };

                this.pc.onicegatheringstatechange = () => {
                    console.log('ICE 수집 상태:', this.pc.iceGatheringState);
                };

                this.pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('ICE 후보 수집됨:', event.candidate.type);
                    } else {
                        console.log('ICE 후보 수집 완료');
                    }
                };

                // 스트림 수신 처리
                this.pc.ontrack = (event) => {
                    console.log('스트림 수신됨:', event.streams.length);
                    this.handleStreamReceived(event);
                };

                // 트랜시버 추가 (모바일 최적화)
                this.pc.addTransceiver('video', { 
                    direction: 'recvonly',
                    streams: []
                });
                this.pc.addTransceiver('audio', { 
                    direction: 'recvonly',
                    streams: []
                });
            }

            async createOffer() {
                // Offer 생성 (모바일 최적화)
                const offer = await this.pc.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true,
                    voiceActivityDetection: false,
                    iceRestart: false
                });
                
                await this.pc.setLocalDescription(offer);
                console.log('Offer 생성 완료');
            }

            async sendWhepRequest() {
                // WHEP 요청 (모바일 최적화 - 타임아웃 연장)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30초 타임아웃

                try {
                    const response = await fetch('https://returnfeed.net/pgm_srt_raw/whep', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/sdp',
                            'User-Agent': navigator.userAgent,
                            'Accept': 'application/sdp'
                        },
                        body: this.pc.localDescription.sdp,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`WHEP 요청 실패: ${response.status} ${response.statusText}`);
                    }

                    const answerSdp = await response.text();
                    
                    await this.pc.setRemoteDescription({
                        type: 'answer',
                        sdp: answerSdp
                    });

                    console.log('WHEP 응답 처리 완료');

                } catch (error) {
                    clearTimeout(timeoutId);
                    throw error;
                }
            }

            handleConnectionStateChange(state) {
                const connectionTime = Date.now() - this.connectionStartTime;
                
                switch (state) {
                    case 'connected':
                        this.isConnected = true;
                        this.isConnecting = false;
                        this.reconnectAttempts = 0;
                        this.updateConnectionStatus('connected');
                        this.showLoadingSpinner(false);
                        this.hideConnectionMessage();
                        this.startStatsMonitoring();
                        console.log(`WebRTC 연결 성공 (${connectionTime}ms)`);
                        break;
                        
                    case 'connecting':
                        this.updateConnectionStatus('connecting');
                        this.showConnectionMessage(`연결 중... (${Math.round(connectionTime/1000)}초)`);
                        break;
                        
                    case 'disconnected':
                        this.isConnected = false;
                        this.updateConnectionStatus('disconnected');
                        this.showConnectionMessage('연결이 끊어졌습니다. 재연결 중...');
                        this.scheduleReconnect();
                        break;
                        
                    case 'failed':
                        this.isConnected = false;
                        this.isConnecting = false;
                        this.updateConnectionStatus('failed');
                        this.showConnectionMessage('WebRTC 연결에 실패했습니다. HLS로 전환 중...');
                        this.handleConnectionError(new Error('WebRTC 연결 실패'));
                        break;
                        
                    case 'closed':
                        this.isConnected = false;
                        this.isConnecting = false;
                        this.updateConnectionStatus('closed');
                        break;
                }
            }

            async handleStreamReceived(event) {
                const video = document.getElementById('videoElement');
                
                if (event.streams && event.streams[0]) {
                    video.srcObject = event.streams[0];
                    console.log('비디오 스트림 설정됨');
                    
                    // 모바일 최적화 재생 처리
                    await this.handleVideoPlay(video);
                }
            }

            async handleVideoPlay(video) {
                try {
                    // 사용자 상호작용이 있었을 때만 자동 재생 시도
                    if (this.userInteracted) {
                        // 비디오 속성 최적화 (모바일)
                        video.playsInline = true;
                        video.muted = true;
                        video.autoplay = true;
                        
                        const playPromise = video.play();
                        
                        if (playPromise !== undefined) {
                            await playPromise;
                            console.log('비디오 재생 시작됨');
                            this.hideMobilePlayButton();
                            this.hideConnectionMessage();
                        }
                    } else {
                        // 사용자 상호작용이 없으면 재생 버튼 표시
                        this.showMobilePlayButton();
                        this.showConnectionMessage('재생 버튼을 눌러 영상을 시작하세요');
                        console.log('사용자 상호작용 대기 중...');
                    }
                } catch (error) {
                    console.log('자동 재생 실패:', error);
                    this.showMobilePlayButton();
                    this.showConnectionMessage('재생 버튼을 눌러 영상을 시작하세요');
                }
            }

            handleConnectionError(error) {
                console.error('연결 오류:', error);
                
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.scheduleReconnect();
                } else {
                    console.log('최대 재연결 시도 횟수 초과, HLS Fallback 모드 시도');
                    this.tryFallbackMode();
                }
            }

            scheduleReconnect() {
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    return;
                }

                const delay = Math.min(2000 * Math.pow(2, this.reconnectAttempts), 15000);
                console.log(`${delay}ms 후 재연결 시도 (${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);
                
                this.showConnectionMessage(`${Math.round(delay/1000)}초 후 재연결 시도...`);
                
                setTimeout(() => {
                    this.reconnectAttempts++;
                    this.startConnection();
                }, delay);
            }

            async tryFallbackMode() {
                console.log('HLS Fallback 모드 시도');
                this.fallbackMode = true;
                this.showConnectionMessage('HLS 스트리밍으로 전환 중...');
                
                const video = document.getElementById('videoElement');
                
                if (Hls.isSupported()) {
                    const hls = new Hls({
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90,
                        maxBufferLength: 30,
                        maxMaxBufferLength: 60
                    });
                    
                    hls.loadSource('https://returnfeed.net/pgm_srt_raw/index.m3u8');
                    hls.attachMedia(video);
                    
                    hls.on(Hls.Events.MANIFEST_PARSED, () => {
                        console.log('HLS 매니페스트 파싱 완료');
                        this.updateConnectionStatus('connected');
                        this.hideConnectionMessage();
                        this.handleVideoPlay(video);
                    });
                    
                    hls.on(Hls.Events.ERROR, (event, data) => {
                        console.error('HLS 오류:', data);
                        this.showConnectionMessage('스트리밍 연결에 실패했습니다. 새로고침을 시도해주세요.');
                    });
                    
                } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    // Safari 네이티브 HLS 지원
                    video.src = 'https://returnfeed.net/pgm_srt_raw/index.m3u8';
                    this.updateConnectionStatus('connected');
                    this.hideConnectionMessage();
                    await this.handleVideoPlay(video);
                } else {
                    this.showConnectionMessage('이 브라우저에서는 스트리밍을 지원하지 않습니다.');
                }
            }

            startStatsMonitoring() {
                if (this.statsInterval) {
                    clearInterval(this.statsInterval);
                }

                this.statsInterval = setInterval(async () => {
                    if (this.pc && this.pc.getStats) {
                        try {
                            const stats = await this.pc.getStats();
                            this.updatePerformanceStats(stats);
                        } catch (e) {
                            console.error('통계 수집 실패:', e);
                        }
                    }
                }, 2000);
            }

            updatePerformanceStats(stats) {
                let rtt = 'N/A', bitrate = 'N/A';
                
                stats.forEach(report => {
                    if (report.type === 'remote-candidate' && report.currentRoundTripTime) {
                        rtt = (report.currentRoundTripTime * 1000).toFixed(0) + 'ms';
                    }
                    if (report.type === 'inbound-rtp' && report.kind === 'video') {
                        const now = Date.now();
                        if (this.lastStats.timestamp > 0) {
                            const bps = 8 * (report.bytesReceived - this.lastStats.bytesReceived) / 
                                       (now - this.lastStats.timestamp);
                            bitrate = (bps / 1000).toFixed(1) + 'kbps';
                        }
                        this.lastStats.bytesReceived = report.bytesReceived;
                        this.lastStats.timestamp = now;
                    }
                });
                
                document.getElementById('rttCounter').textContent = rtt;
                document.getElementById('bitrateCounter').textContent = bitrate;
            }

            updateConnectionStatus(status) {
                const statusDot = document.getElementById('statusDot');
                const connectionText = document.getElementById('connectionText');
                const statusIndicator = document.getElementById('statusIndicator');
                
                statusDot.className = 'status-dot';
                
                switch (status) {
                    case 'connected':
                        statusDot.classList.add('connected');
                        connectionText.textContent = '연결됨';
                        statusIndicator.textContent = this.fallbackMode ? 'HLS 연결됨' : 'WebRTC 연결됨';
                        break;
                    case 'connecting':
                        statusDot.classList.add('connecting');
                        connectionText.textContent = '연결 중...';
                        statusIndicator.textContent = '연결 중';
                        break;
                    case 'failed':
                    case 'disconnected':
                        connectionText.textContent = '연결 실패';
                        statusIndicator.textContent = '연결 실패';
                        break;
                    default:
                        connectionText.textContent = '대기 중';
                        statusIndicator.textContent = '대기 중';
                }
            }

            showLoadingSpinner(show) {
                const spinner = document.getElementById('loadingSpinner');
                spinner.style.display = show ? 'block' : 'none';
            }

            showMobilePlayButton() {
                const button = document.getElementById('mobilePlayButton');
                button.classList.add('visible');
            }

            hideMobilePlayButton() {
                const button = document.getElementById('mobilePlayButton');
                button.classList.remove('visible');
            }

            showConnectionMessage(message) {
                const messageEl = document.getElementById('connectionMessage');
                messageEl.textContent = message;
                messageEl.classList.add('visible');
            }

            hideConnectionMessage() {
                const messageEl = document.getElementById('connectionMessage');
                messageEl.classList.remove('visible');
            }

            async handleMobilePlayButtonClick() {
                const video = document.getElementById('videoElement');
                this.userInteracted = true;
                
                try {
                    await video.play();
                    console.log('수동 비디오 재생 시작됨');
                    this.hideMobilePlayButton();
                    this.hideConnectionMessage();
                } catch (error) {
                    console.error('수동 재생 실패:', error);
                    this.showConnectionMessage('재생에 실패했습니다. 다시 시도해주세요.');
                }
            }

            close() {
                if (this.pc) {
                    this.pc.close();
                    this.pc = null;
                }
                
                if (this.statsInterval) {
                    clearInterval(this.statsInterval);
                    this.statsInterval = null;
                }
                
                if (this.connectionTimeout) {
                    clearTimeout(this.connectionTimeout);
                    this.connectionTimeout = null;
                }
                
                this.isConnected = false;
                this.isConnecting = false;
            }
        }

        // 메인 애플리케이션 클래스 (모바일 최적화)
        class UltraMobileReturnFeedApp {
            constructor() {
                this.currentView = 'splash';
                this.myCamera = null;
                this.inputList = {};
                this.tallyState = { program: null, preview: null };
                this.settings = this.loadSettings();
                this.isOverlayVisible = false;
                this.overlayTimeout = null;
                this.ws = null;
                this.webrtcSystem = new UltraMobileWebRTCSystem();
                this.audioSystem = new UltraForcedMaleAudioSystem();
                this.lastTallyState = { state: 'off' };
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.userInteracted = false;
                this.syncTimer = null;
                this.initialSyncCompleted = false;
                
                this.init();
            }

            async init() {
                await this.showSplashScreen();
                this.setupEventListeners();
                this.showSetupScreen();
                this.connectWebSocket();
            }

            async showSplashScreen() {
                // 1.2초 후 스플래시 화면 숨김
                await new Promise(resolve => setTimeout(resolve, 1200));
                document.getElementById('splashScreen').classList.add('hidden');
            }

            showSetupScreen() {
                document.getElementById('setupScreen').classList.add('active');
                this.animateSetupScreen();
            }

            async animateSetupScreen() {
                const statusElement = document.getElementById('setupStatus');
                const formElement = document.getElementById('setupForm');
                
                const steps = [
                    { text: "극강 남성 음성 시스템 로딩 중...", delay: 400 },
                    { text: "모바일 WebRTC 최적화 중...", delay: 800 },
                    { text: "ReturnFeed 시스템 준비 완료", delay: 1200 }
                ];

                for (let i = 0; i < steps.length; i++) {
                    await new Promise(resolve => {
                        setTimeout(() => {
                            statusElement.textContent = steps[i].text;
                            if (i === steps.length - 1) {
                                statusElement.style.opacity = '0';
                                formElement.classList.add('ready');
                            }
                            resolve();
                        }, steps[i].delay);
                    });
                }
            }

            setupEventListeners() {
                // 카메라 선택
                document.getElementById('cameraSelect').addEventListener('change', (e) => {
                    this.handleCameraSelect(e.target.value);
                });

                // 터치 이벤트 (모바일 최적화)
                const touchArea = document.getElementById('touchArea');
                
                // 터치 시작
                touchArea.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleUserInteraction();
                    this.toggleOverlay();
                }, { passive: false });

                // 클릭 (PC용)
                touchArea.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.handleUserInteraction();
                    this.toggleOverlay();
                });

                // 모바일 재생 버튼
                document.getElementById('mobilePlayButton').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.handleUserInteraction();
                    this.webrtcSystem.handleMobilePlayButtonClick();
                });

                // 설정 토글
                document.querySelectorAll('.switch input').forEach(toggle => {
                    toggle.addEventListener('change', (e) => {
                        this.handleSettingToggle(e.target.id, e.target.checked);
                    });
                });

                // 페이지 가시성 변경
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        this.reconnectIfNeeded();
                    }
                });

                // 네트워크 상태 변경
                window.addEventListener('online', () => {
                    console.log('네트워크 연결 복구됨');
                    this.reconnectAll();
                });

                window.addEventListener('offline', () => {
                    console.log('네트워크 연결 끊김');
                    this.webrtcSystem.updateConnectionStatus('offline');
                });

                // 키보드 단축키 (테스트용)
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'KeyT' && e.ctrlKey) {
                        e.preventDefault();
                        this.audioSystem.testVoice('Test Male Voice');
                    }
                    if (e.code === 'KeyS' && e.ctrlKey) {
                        e.preventDefault();
                        this.audioSystem.speak('Standby');
                    }
                    if (e.code === 'KeyC' && e.ctrlKey) {
                        e.preventDefault();
                        this.audioSystem.speak('Cut');
                    }
                    if (e.code === 'KeyR' && e.ctrlKey) {
                        e.preventDefault();
                        this.audioSystem.forceReloadVoices();
                    }
                });
            }

            handleUserInteraction() {
                if (!this.userInteracted) {
                    this.userInteracted = true;
                    this.audioSystem.setUserInteracted();
                    this.webrtcSystem.userInteracted = true;
                    console.log('사용자 상호작용 처리됨');
                }
            }

            handleCameraSelect(value) {
                if (!value) return;
                
                const [numStr, ...nameParts] = value.split(':');
                const camNumber = parseInt(numStr);
                const camName = nameParts.join(':');
                
                this.myCamera = { number: camNumber, name: camName };
                this.showPlayerScreen();
                
                if (camNumber === 0) {
                    this.settings.vibration = false;
                    this.settings.audio = false;
                    this.updateSettingsUI();
                }
            }

            showPlayerScreen() {
                document.getElementById('setupScreen').classList.remove('active');
                document.getElementById('playerScreen').classList.add('active');
                this.currentView = 'player';
                
                // CAM 타이틀 업데이트
                const title = this.myCamera.number === 0 ? 'PGM' : `CAM ${this.myCamera.number}`;
                document.getElementById('camTitle').textContent = title;
                
                // WebRTC 연결 시작
                this.webrtcSystem.startConnection();
                
                // 설정 복원
                this.updateSettingsUI();

                // 강화된 초기 동기화 시작
                this.startAggressiveInitialSync();
            }

            async connectWebSocket() {
                try {
                    if (this.ws) {
                        this.ws.close();
                    }

                    this.ws = new WebSocket('wss://returnfeed.net/ws/');
                    
                    const connectionTimeout = setTimeout(() => {
                        if (this.ws.readyState === WebSocket.CONNECTING) {
                            this.ws.close();
                            console.log('WebSocket 연결 타임아웃');
                        }
                    }, 15000); // 모바일용 타임아웃 연장

                    this.ws.onopen = () => {
                        clearTimeout(connectionTimeout);
                        console.log('WebSocket 연결됨');
                        this.reconnectAttempts = 0;
                        
                        // 즉시 강화된 상태 동기화 시작
                        this.startAggressiveInitialSync();
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketMessage(data);
                        } catch (e) {
                            console.error('WebSocket 메시지 파싱 오류:', e);
                        }
                    };

                    this.ws.onclose = (event) => {
                        clearTimeout(connectionTimeout);
                        console.log('WebSocket 연결 끊김:', event.code);
                        
                        // 지수 백오프로 재연결
                        if (this.reconnectAttempts < this.maxReconnectAttempts) {
                            const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 10000);
                            setTimeout(() => {
                                this.reconnectAttempts++;
                                this.connectWebSocket();
                            }, delay);
                        }
                    };

                    this.ws.onerror = (error) => {
                        clearTimeout(connectionTimeout);
                        console.error('WebSocket 오류:', error);
                    };

                } catch (error) {
                    console.error('WebSocket 연결 실패:', error);
                }
            }

            // 강화된 초기 동기화 (초기 탈리 신호 문제 완전 해결)
            startAggressiveInitialSync() {
                if (this.initialSyncCompleted) return;

                // 즉시 상태 요청
                this.requestFullState();

                // 0.2초마다 20번 연속 요청 (극강 초기 동기화)
                let syncCount = 0;
                const initialSync = setInterval(() => {
                    this.requestFullState();
                    syncCount++;
                    
                    if (syncCount >= 20) {
                        clearInterval(initialSync);
                        this.initialSyncCompleted = true;
                        
                        // 이후 정상적인 주기적 동기화 시작
                        this.startPeriodicSync();
                    }
                }, 200);
            }

            requestFullState() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ command: 'get_full_state' }));
                    console.log('전체 상태 요청 전송');
                }
            }

            startPeriodicSync() {
                // 1초마다 상태 동기화 (극강 빈도)
                this.syncTimer = setInterval(() => {
                    this.requestFullState();
                }, 1000);
            }

            handleWebSocketMessage(data) {
                if (data.type === 'input_list' || data.type === 'full_state') {
                    this.inputList = data.inputs || {};
                    this.updateCameraOptions();
                }
                
                if (data.type === 'tally_update' || data.type === 'full_state') {
                    this.tallyState = { program: data.program, preview: data.preview };
                    this.updateTallyState();
                }
            }

            updateCameraOptions() {
                const select = document.getElementById('cameraSelect');
                const currentValue = select.value;
                
                // 기존 옵션 제거 (기본 옵션 제외)
                while (select.children.length > 1) {
                    select.removeChild(select.lastChild);
                }
                
                // 새 옵션 추가
                Object.entries(this.inputList).forEach(([num, name]) => {
                    const option = document.createElement('option');
                    option.value = `${num}:${name}`;
                    option.textContent = `CAM ${num}: ${name.substring(0, 15)}${name.length > 15 ? '...' : ''}`;
                    select.appendChild(option);
                });
                
                // 구분선 및 PGM 옵션
                const separator = document.createElement('option');
                separator.value = '';
                separator.textContent = '---';
                separator.disabled = true;
                select.appendChild(separator);
                
                const pgmOption = document.createElement('option');
                pgmOption.value = '0:PGM Only';
                pgmOption.textContent = 'PGM만 보기 (Tally 기능 OFF)';
                select.appendChild(pgmOption);
                
                // 이전 선택값 복원
                if (currentValue) {
                    select.value = currentValue;
                }
            }

            updateTallyState() {
                if (!this.myCamera || this.currentView !== 'player') return;
                
                let currentTally = 'off';
                if (this.myCamera.number !== 0) {
                    if (this.myCamera.number === this.tallyState.program) {
                        currentTally = 'pgm';
                    } else if (this.myCamera.number === this.tallyState.preview) {
                        currentTally = 'pvw';
                    }
                }
                
                // 상태 변경 시에만 처리 (극강 반응성)
                if (this.lastTallyState.state !== currentTally) {
                    console.log(`탈리 상태 변경: ${this.lastTallyState.state} → ${currentTally}`);
                    this.lastTallyState.state = currentTally;
                    this.applyTallyVisual(currentTally);
                    this.triggerFeedback(currentTally);
                }
            }

            applyTallyVisual(state) {
                const container = document.getElementById('tallyContainer');
                
                // 기존 클래스 제거
                container.className = 'tally-container';
                
                if (state === 'pgm') {
                    container.classList.add('pgm-tally', 'flash-pgm');
                    setTimeout(() => container.classList.remove('flash-pgm'), 100);
                } else if (state === 'pvw') {
                    container.classList.add('pvw-tally', 'flash-pvw');
                    setTimeout(() => container.classList.remove('flash-pvw'), 100);
                }
            }

            triggerFeedback(state) {
                // 진동 피드백
                if (this.settings.vibration && navigator.vibrate) {
                    if (state === 'pvw') {
                        navigator.vibrate([80, 40, 80]); // 짧게 두 번
                    } else if (state === 'pgm') {
                        navigator.vibrate(250); // 길게 한 번
                    }
                }

                // 음성 안내 (극강 남성 시스템 사용)
                if (this.settings.audio) {
                    this.playAudioGuide(state);
                }
            }

            playAudioGuide(state) {
                if (state === 'pvw') {
                    this.audioSystem.speak('Standby', 'high');
                } else if (state === 'pgm') {
                    this.audioSystem.speak('Cut', 'high');
                }
                // off 상태에서는 음성 없음
            }

            toggleOverlay() {
                this.isOverlayVisible = !this.isOverlayVisible;
                
                const overlayControls = document.getElementById('overlayControls');
                const camTitle = document.getElementById('camTitle');
                const performanceMonitor = document.getElementById('performanceMonitor');

                if (this.isOverlayVisible) {
                    overlayControls.classList.add('visible');
                    camTitle.classList.add('visible');
                    
                    if (this.settings.performance) {
                        performanceMonitor.classList.add('visible');
                    }
                    
                    // 3초 후 자동 숨김
                    if (this.overlayTimeout) {
                        clearTimeout(this.overlayTimeout);
                    }
                    this.overlayTimeout = setTimeout(() => {
                        this.hideOverlay();
                    }, 3000);
                } else {
                    this.hideOverlay();
                }
            }

            hideOverlay() {
                this.isOverlayVisible = false;
                
                document.getElementById('overlayControls').classList.remove('visible');
                document.getElementById('camTitle').classList.remove('visible');
                document.getElementById('performanceMonitor').classList.remove('visible');
                
                if (this.overlayTimeout) {
                    clearTimeout(this.overlayTimeout);
                    this.overlayTimeout = null;
                }
            }

            handleSettingToggle(settingId, checked) {
                switch (settingId) {
                    case 'vibrationToggle':
                        this.settings.vibration = checked;
                        break;
                    case 'audioToggle':
                        this.settings.audio = checked;
                        break;
                    case 'conserveToggle':
                        this.settings.mode = checked ? 'conserve' : 'normal';
                        break;
                    case 'performanceToggle':
                        this.settings.performance = checked;
                        const monitor = document.getElementById('performanceMonitor');
                        if (checked && this.isOverlayVisible) {
                            monitor.classList.add('visible');
                        } else {
                            monitor.classList.remove('visible');
                        }
                        break;
                }
                
                this.saveSettings();
            }

            updateSettingsUI() {
                document.getElementById('vibrationToggle').checked = this.settings.vibration;
                document.getElementById('audioToggle').checked = this.settings.audio;
                document.getElementById('conserveToggle').checked = this.settings.mode === 'conserve';
                document.getElementById('performanceToggle').checked = this.settings.performance || false;
            }

            reconnectIfNeeded() {
                if (this.ws && this.ws.readyState !== WebSocket.OPEN) {
                    this.connectWebSocket();
                }
                if (!this.webrtcSystem.isConnected) {
                    this.webrtcSystem.startConnection();
                }
            }

            async reconnectAll() {
                console.log('전체 재연결 시도');
                await Promise.all([
                    this.connectWebSocket(),
                    this.webrtcSystem.startConnection()
                ]);
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('returnfeed_settings_ultra_mobile_v1');
                    return saved ? JSON.parse(saved) : { 
                        vibration: true, 
                        audio: true, 
                        mode: 'normal',
                        performance: false
                    };
                } catch {
                    return { 
                        vibration: true, 
                        audio: true, 
                        mode: 'normal',
                        performance: false
                    };
                }
            }

            saveSettings() {
                try {
                    localStorage.setItem('returnfeed_settings_ultra_mobile_v1', JSON.stringify(this.settings));
                } catch (error) {
                    console.error('설정 저장 실패:', error);
                }
            }
        }

        // 앱 시작
        document.addEventListener('DOMContentLoaded', () => {
            new UltraMobileReturnFeedApp();
        });

        // 서비스 워커 등록 (오프라인 지원)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(err => {
                console.log('Service Worker 등록 실패:', err);
            });
        }
    </script>
</body>
</html>

