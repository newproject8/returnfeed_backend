

# **ReturnFeed 전략 확장: Blackmagic Design 에코시스템 통합을 위한 기술 청사진**

## **Executive Summary**

본 보고서는 현재 vMix 기반으로 운영되는 ReturnFeed 플랫폼을 Blackmagic Design(BMD) 제품 에코시스템으로 확장하기 위한 포괄적인 기술 분석 및 전략적 실행 계획을 제시한다. 이 확장은 ReturnFeed의 잠재 시장(Total Addressable Market, TAM)을 기존 vMix 사용자 기반을 넘어, 방송 업계에서 막대한 점유율을 차지하고 있는 BMD 하드웨어 사용자까지 포괄하는 중대한 전략적 전환을 의미한다.

보고서의 핵심 권고 사항은 PD(Producer Director) 소프트웨어 내에 새로운 \*\*장치 추상화 계층(Device Abstraction Layer)\*\*을 도입하여, vMix와 ATEM 스위처를 포함한 다양한 하드웨어를 원활하게 관리하는 것이다. ATEM 스위처의 탈리(Tally) 정보 제어를 위해, 공식 SDK의 복잡성을 피하고 개발 속도를 극대화할 수 있는 커뮤니티 기반의 Python 라이브러리(PyATEMMax 또는 pyatem) 활용을 제안한다.

프로그램(PGM) 피드 수집과 관련하여, 사용자가 제안한 NDI Proxy 기반의 스트림 표준화 방식은 심층 분석 결과, 시스템의 핵심 가치인 초저지연(\<75ms) 목표 달성에 부적합한 것으로 판명되었다. 대신, DeckLink 캡처 카드를 통해 SDI 신호를 직접 수신하고, GStreamer와 FFmpeg를 파이프라인으로 연결하여 실시간으로 인코딩하는 **직접 캡처 및 인코딩 아키텍처**를 제안한다. 이 방식은 불필요한 변환 과정을 제거하여 지연 시간을 최소화하고 시스템 자원 사용을 최적화한다.

본 보고서는 이러한 아키텍처 변경을 위한 구체적인 다중 프로세스 구현 계획, 최종 사용자를 위한 하드웨어 스택 권장 사항, 그리고 시장 출시를 위한 단계별 실행 로드맵을 포함한다. 이 전략적 확장을 통해 ReturnFeed는 특정 소프트웨어에 종속된 유틸리티에서 벗어나, 하드웨어에 구애받지 않는 범용 원격 제작 협업 플랫폼으로 도약하며 강력한 시장 경쟁력을 확보할 수 있을 것이다.

---

## **Part 1: 에코시스템 분석: Blackmagic Design 하드웨어 통합**

Blackmagic Design 에코시스템을 ReturnFeed에 통합하기 위한 첫 단계는 제어 프로토콜과 비디오 피드 획득 경로를 심층적으로 분석하는 것이다. 이 분석은 향후 아키텍처 설계의 기술적 토대를 마련하는 데 필수적이다. 본 파트에서는 ATEM 스위처의 탈리 정보 획득 방법과 PGM 비디오 피드 캡처 방식을 면밀히 검토하여 가장 실용적이고 성능이 뛰어난 통합 경로를 도출한다.

### **1.1. ATEM 스위처 제어: 탈리 및 상태 획득**

BMD 장비 지원의 핵심 과제는 ATEM 스위처와 연동하여 실시간 탈리 상태(Program/Preview)를 획득하는 것이다. vMix의 명확한 TCP API와 달리, ATEM 에코시스템은 여러 가지 제어 방법을 제공하며, 각 방법은 공식 지원 여부, 구현 용이성, 장기적 안정성 측면에서 뚜렷한 장단점을 가진다.

#### **1.1.1. 공식 Blackmagic ATEM SDK**

* **설명:** Blackmagic Design은 ATEM 스위처 제어를 위한 공식 SDK를 제공한다.1 이 SDK의 핵심은 Windows 플랫폼의 컴포넌트 객체 모델(Component Object Model, COM) 인터페이스이며, 다른 플랫폼을 위한 래퍼(Wrapper)가 함께 제공된다.3 이는 제조사가 공식적으로 승인하고 지원하는 통합 방식이다.  
* **기능:** SDK는 스위처에 대한 포괄적인 제어 기능을 노출한다. 입력 소스를 순회하고(IBMDSwitcherInputIterator), 각 소스의 탈리 상태를 조회하며(IsProgramTallied, IsPreviewTallied), 콜백 함수를 통해 상태 변경을 실시간으로 통지받는 기능(IBMDSwitcherInputCallback의 bmdSwitcherInputEventTypeIsProgramTalliedChanged 이벤트)을 포함한다.3 또한, 믹스 이펙트(Mix Effect, M/E) 블록의 Program/Preview 소스를 설정하고 조회하는 기능도 제공한다.3  
* **통합 과제:** 가장 큰 단점은 COM 기반 아키텍처에 있다.3 이를 기존의 Python/PyQt5 기반 PD 소프트웨어에 직접 통합하는 것은 간단하지 않다. Python 친화적인 API를 노출하는 C++ 래퍼 모듈을 개발하거나, Python의  
  comtypes 라이브러리를 사용해야 하는데, 이는 번거롭고 "Pythonic"하지 않은 접근 방식이다. 이 경로는 상당한 개발 오버헤드와 복잡성을 야기한다.  
* **안정성과 민첩성의 상충 관계:** 공식 SDK를 사용하는 것은 Blackmagic이 예고 없이 API를 변경할 가능성이 낮기 때문에 가장 높은 수준의 미래 호환성과 안정성을 보장한다.1 그러나 COM 인터페이스를 Python과 연동시키는 데 필요한 개발 노력은 상당하며, 이는 BMD 지원 기능의 시장 출시 시간(Time-to-Market)을 지연시키는 직접적인 원인이 된다. 반면, 비공식적인 대안들은 구현 속도는 빠르지만 향후 ATEM 펌웨어 업데이트 시 호환성이 깨질 위험을 내포한다. 이는 장기적 안정성을 위해 초기 개발에 많은 투자를 할 것인가(공식 SDK), 아니면 관리 가능한 수준의 위험을 감수하며 개발 속도와 민첩성을 우선시할 것인가(비공식 라이브러리)라는 전형적인 엔지니어링 트레이드오프를 제시한다. 이 결정은 초기 개발 주기뿐만 아니라 제품의 장기적인 유지보수 전략에도 영향을 미친다.

#### **1.1.2. 리버스 엔지니어링된 UDP 프로토콜과 Python 라이브러리**

* **설명:** ATEM 스위처와 공식 ATEM Software Control 패널 간의 통신은 문서화되지 않은 독점적인 UDP 프로토콜을 통해 이루어진다.4 Kasper Skårhøj를 비롯한 개발자 커뮤니티는 이 프로토콜을 광범위하게 리버스 엔지니어링했으며, 그 결과 이 프로토콜을 구현한 여러 강력한 Python 라이브러리가 탄생했다.6  
* **주요 라이브러리:**  
  * **PyATEMMax:** ATEMmax Arduino 라이브러리를 Python으로 직접 포팅한 것으로, 기능이 풍부하고 자동 재연결, 다중 스위처 동시 연결을 지원한다.7 Python 3 외에 외부 종속성이 없어 사용자 친화적으로 설계되었다.7 특히 PGM/PVW 상태를 조회하는 명시적인 메서드를 제공하여 탈리 목적에 매우 적합하다.7  
  * **pyatem (OpenSwitcher):** ATEM 프로토콜을 구현한 또 다른 강력한 라이브러리다.11 이벤트 기반으로 작동하여, 개발자가  
    change:program-bus-input:0과 같은 특정 상태 변경 이벤트를 구독하여 PGM 소스 업데이트를 수신할 수 있다.12 이러한 이벤트 기반 모델은 ReturnFeed와 같은 실시간 애플리케이션에 매우 효율적이다.  
* **통합 이점:** 이 라이브러리들은 기존 Python 기반 PD 소프트웨어에 직접적이고 원활하게 통합될 수 있다. 이는 공식 SDK에 비해 개발 시간과 복잡성을 극적으로 줄여준다. 탈리 상태를 가져오는 코드 예제는 매우 직관적이다.10  
* **위험 요소:** 가장 큰 위험은 이 라이브러리들이 비공식적이고 리버스 엔지니어링된 프로토콜에 의존한다는 점이다.5 향후 Blackmagic의 ATEM 펌웨어 업데이트가 UDP 프로토콜에 호환되지 않는 변경을 가져올 수 있으며, 이 경우 라이브러리 유지보수자의 패치에 의존해야 한다. 비록 핵심 프로토콜이 수년간 안정적으로 유지되어 왔지만, 제3의 커뮤니티 지원 라이브러리에 대한 의존성은 반드시 관리해야 할 위험이다.

#### **1.1.3. 권장 사항 및 아키텍처적 시사점**

* **권장 사항:** 초기 구현 단계에서는 **PyATEMMax 또는 pyatem과 같이 성숙한 Python 라이브러리를 사용할 것을 강력히 권장한다.** 개발 시간과 복잡성의 현저한 감소는 비공식 프로토콜 의존이라는 관리 가능한 위험을 훨씬 상회하는 이점을 제공한다. 이 라이브러리들을 둘러싼 활발한 커뮤니티는 잠재적인 프로토콜 변경이 발생하더라도 신속하게 해결될 가능성이 높음을 시사한다.  
* **아키텍처 설계 원칙:** 장기적인 위험을 완화하기 위해, PD 소프트웨어 아키텍처는 반드시 \*\*장치 추상화 계층(Device Abstraction Layer)\*\*을 포함해야 한다. 즉, 핵심 로직이 PyATEMMax 함수를 직접 호출해서는 안 된다. 대신, connect(), get\_tally\_state(), on\_tally\_change()와 같은 메서드를 가진 인터페이스(예: 추상 기본 클래스) TallyController와 상호작용해야 한다. PyAtemTallyController라는 구체적인 클래스가 선택된 라이브러리를 사용하여 이 인터페이스를 구현하게 된다. 이 설계 패턴을 적용하면, 향후 공식 SDK로 전환하기로 결정하더라도 주 애플리케이션 로직을 변경하지 않고 새로운 OfficialSdkTallyController 클래스를 작성하는 것만으로 대응할 수 있다.  
* **표 1.1: ATEM 제어 방식 비교 분석**  
  * **목적:** 이 표는 다양한 제어 방식 간의 장단점을 한눈에 파악할 수 있도록 요약하여, 이해관계자들이 기술적, 전략적 요소를 쉽게 이해하고 최종 권장 사항을 지지할 수 있도록 돕는다.  
  * **내용:**

| 방식 | 공식 지원 | Python 통합 난이도 | 장기적 안정성 | 개발 속도 | 주요 라이브러리/도구 |
| :---- | :---- | :---- | :---- | :---- | :---- |
| **공식 ATEM SDK** | 예 | 높음 (COM 기반) | 매우 높음 | 느림 | Blackmagic ATEM SDK 1 |
| **리버스 엔지니어링 UDP** | 아니요 | 낮음 (네이티브 Python) | 중간 (펌웨어 의존) | 빠름 | PyATEMMax, pyatem 7 |
| **텍스트 기반 이더넷 프로토콜** | 예 (제한적) | 중간 (Telnet/Socket) | 높음 | 중간 | Telnet, Sockets 4 |

### **1.2. 프로그램 피드 획득: 캡처-인코딩 체인**

vMix와의 결정적인 차이점은 ATEM 스위처가 NDI와 같은 프로토콜을 통해 네트워크로 PGM 피드를 기본적으로 출력하지 않는다는 점이다.14 따라서 ReturnFeed 시스템을 위한 PGM 피드 획득은 물리적인 비디오 출력을 캡처하는 과정을 반드시 필요로 한다.

#### **1.2.1. 물리적 출력과 캡처 카드의 필요성**

* **ATEM 출력:** ATEM 스위처는 전용 SDI 및/또는 HDMI 출력을 통해 PGM 피드를 제공한다.16 ATEM Mini 시리즈와 같은 일부 모델은 웹캠처럼 작동하는 USB-C 출력을 제공하지만 17, 이 스트림은 일반적으로 압축되어 있으며(주로 MJPEG) SDI/HDMI 출력에 비해 품질이 낮고 잠재적으로 지연 시간이 더 길다는 보고가 있다.19 ReturnFeed와 같은 전문적인 초저지연 시스템에서 웹캠 출력에 의존하는 것은 권장되지 않는다.  
* **캡처 카드의 역할:** SDI 또는 HDMI 출력으로부터 고품질, 저지연 PGM 피드를 PD 소프트웨어로 수집하기 위해서는 전용 캡처 카드가 필수적이다. 가장 시너지 효과가 크고 널리 지원되는 선택은 Blackmagic Design의 DeckLink 카드다.20 이 카드들은 SDI/HDMI I/O의 업계 표준이며, 견고한 드라이버와 SDK 지원을 제공한다.  
* **비용 및 복잡성:** 이는 vMix 전용 워크플로우에서는 필요하지 않았던 필수 하드웨어 구성 요소를 최종 사용자에게 요구하게 된다. DeckLink Mini Recorder 4K와 같은 캡처 카드는 약 200-215달러의 추가 비용을 발생시킨다.23 이 점은 마케팅, 문서 및 시스템 요구 사항에서 사용자에게 명확하게 전달되어야 한다.

#### **1.2.2. 저지연 캡처: SDI 대 NDI**

* **SDI:** 직렬 디지털 인터페이스(Serial Digital Interface)는 동축 케이블을 통해 비압축 비디오를 전송하는 전문 방송 표준이다. 신뢰성과 극도로 낮은 지연 시간(종종 1프레임 미만)으로 잘 알려져 있다.27 ATEM의 SDI 출력에서 DeckLink 카드를 통해 PD 소프트웨어로 직접 캡처하는 것이 가장 직접적이고 지연 시간이 가장 짧은 경로이다.  
* **NDI:** 네트워크 장치 인터페이스(Network Device Interface)는 인기 있는 IP 기반 비디오 프로토콜이다. 효율적이기는 하지만, 압축 및 네트워크 관련 지연을 유발하며, 이는 본질적으로 직접적인 SDI 연결보다 높다.27 ATEM에서 NDI 스트림을 생성하려면 외부 하드웨어 변환기(예: BirdDog 컨버터) 또는 소프트웨어 브리지가 필요하다.15  
* **편의성에 숨겨진 지연 시간:** NDI는 표준 이더넷 인프라를 활용하는 편의성을 제공하지만, 이 편의성은 성능을 희생시킨다. 핵심 가치 제안이 *초저지연* (\<75ms)인 시스템에서는 모든 밀리초가 중요하다. ATEM → SDI 출력 → NDI 인코더 → 네트워크 → PD 소프트웨어로 이어지는 과정은 ReturnFeed의 인코딩 프로세스가 시작되기도 전에 여러 프레임의 지연을 추가한다.28 이는 프로젝트의 성능 목표와 정면으로 충돌한다. 따라서 가장 견고하고 성능이 뛰어난 아키텍처는 직접적인 SDI-캡처 카드 경로를 우선시해야 한다. 사용자가 제안한 NDI Proxy 사용은 Part 3에서 자세히 분석되겠지만, 이 초기 분석은 캡처 단계에서 NDI를 도입하는 것이 시스템의 핵심 임무에 역행함을 보여준다.

#### **1.2.3. PGM 획득 권장 사항**

* **권장 사항:** PD 소프트웨어는 ATEM의 PGM 출력에서 나오는 SDI 또는 HDMI 신호를 수신하는 Blackmagic DeckLink 카드로부터 직접 비디오를 캡처하도록 설계되어야 한다. 이것이 ReturnFeed 플랫폼이 요구하는 저지연과 고품질을 보장하는 유일한 접근 방식이다.  
* **구현 참고:** 소프트웨어 구현 시 장치 선택, 포맷 협상, 캡처 루프 처리가 필요하며, 이는 Part 2.2.2에서 상세히 다룰 것이다.

### **1.3. 더 넓은 에코시스템: 카메라 제어와 미래 시너지**

ATEM과의 통합은 단순한 탈리 기능을 넘어 훨씬 더 깊은 기능 세트로의 문을 열어준다.

* **Blackmagic SDI 카메라 제어:** BMD 카메라는 리턴 SDI 피드에 내장된 프로토콜을 통해 ATEM 스위처에서 직접 제어할 수 있다.2 ATEM SDK와 이를 리버스 엔지니어링한 라이브러리들은 이 기능(  
  CameraControlCommand)에 대한 접근을 제공한다.32  
* **Blackmagic Cloud:** BMD는 프로젝트 협업, 미디어 동기화, 심지어 Streaming Bridge 제품을 통한 원격 스트리밍 링크를 위한 클라우드 에코시스템을 구축하고 있다.33  
* **"탈리 툴"에서 "원격 제작 허브"로의 전략적 전환:** 초기 요청은 탈리 지원을 위한 BMD 통합이지만, 이를 위해 필요한 기본 기술(ATEM 제어 라이브러리)은 카메라 제어 기능까지 함께 제공한다.32 이는 엄청난 전략적 기회를 제시한다. ReturnFeed는 수동적인 탈리/리턴 시스템에서 능동적인 원격 제작 허브로 진화할 수 있다. 미래 버전에서는 PD가 동일한 소프트웨어 내에서 탈리를 보내는 것뿐만 아니라, 연결된 Blackmagic 카메라의 조리개, 게인, 초점, 색상을 원격으로 조정할 수 있게 될 것이다. 이는 중요한 경쟁 차별화 요소이자 강력한 상향 판매(upsell) 기회가 되어 제품을 더 높은 가치 범주로 이동시킬 것이다. 오늘 설계하는 아키텍처는 이러한 미래를 예측하여, 장치 추상화 계층이 카메라 제어 명령을 포함하도록 확장될 수 있도록 해야 한다.

---

## **Part 2: 통합을 위한 아키텍처 청사진**

이 섹션에서는 vMix와 Blackmagic Design 장치를 모두 지원하기 위해 Python 기반 PD 소프트웨어에 필요한 아키텍처 변경 사항을 상세히 설명하고 구체적인 구현 계획을 제공한다.

### **2.1. 제안 시스템 아키텍처: 통합된 접근 방식**

핵심 원칙은 하드웨어별 로직을 추상화하여 주 애플리케이션이 일반적인 "장치" 개념으로 작동하도록 하는 것이다.

#### **2.1.1. 장치 추상화 계층 (Device Abstraction Layer, DAL)**

PD 소프트웨어에 새로운 계층이 도입될 것이다. 이 계층은 모든 장치 상호 작용을 위한 인터페이스 세트(Python의 추상 기본 클래스)를 정의한다.

* **Device 인터페이스:** 연결된 모든 프로덕션 장치를 나타내는 기본 클래스. name, status와 같은 속성과 connect(), disconnect()와 같은 메서드를 가진다.  
* **TallyProvider 인터페이스:** get\_tally\_state()와 같은 메서드와 on\_tally\_update(states) 이벤트를 가진 인터페이스.  
* **VideoProvider 인터페이스:** start\_capture(), stop\_capture()와 같은 메서드와 on\_new\_frame(frame) 이벤트를 가진 인터페이스.  
* **구체적인 구현:**  
  * VmixDevice(TallyProvider, VideoProvider): 기존 vMix 로직이 이 클래스로 리팩토링된다. 탈리는 TCP API에서 읽고, PGM 비디오는 NDI 소스에서 캡처한다.  
  * AtemDevice(TallyProvider, VideoProvider): BMD 지원을 위한 새로운 클래스. 탈리는 PyATEMMax를 사용하여 읽는다.7 PGM 비디오는 새로운 GStreamer 기반 캡처 모듈을 통해 DeckLink 카드에서 캡처한다.

#### **2.1.2. 장치 선택을 위한 UI/UX**

PD 소프트웨어의 시작 또는 설정 화면에는 장치 관리를 위한 새로운 UI가 필요하다.

* 연결된 장치(네트워크상의 vMix 인스턴스, 설치된 DeckLink 카드)를 자동으로 감지해야 한다.  
* UI는 명확한 레이블, 일관된 컨트롤, 시각적 피드백과 같은 모범 사례를 따라야 한다.35 사용자가 "vMix @ localhost" 또는 "ATEM via DeckLink Mini Recorder 4K"와 같은 기본 장치를 선택할 수 있도록 해야 한다. vMix의 입력 설정 UI는 잘 구성된 설정 패널의 좋은 참고 자료가 될 수 있다.37

### **2.2. PD 소프트웨어 구현 계획 (Python)**

이 섹션에서는 저지연 성능과 안정성을 보장하기 위해 AtemDevice 구현을 위한 견고한 다중 프로세스 아키텍처를 설명한다. 캡처 및 인코딩 작업은 블로킹(blocking)을 방지하고 독립적인 최적화를 허용하기 위해 분리될 것이다.

#### **2.2.1. 모듈 1: ATEM 탈리 및 상태 관리 (메인 프로세스)**

* **라이브러리:** PyATEMMax는 직관적인 동기식 API를 제공하여 기존 애플리케이션 루프에 쉽게 통합할 수 있으므로 권장된다.7  
* **구현:**  
  1. 시작 시 PyATEMMax.ATEMMax()를 인스턴스화한다.  
  2. ATEM의 IP 주소로 연결한다: switcher.connect(ip).  
  3. 주 애플리케이션 루프에서 탈리 상태 변경을 폴링(polling)한다. 라이브러리는 상태를 자동으로 최신으로 유지한다.7  
  4. 전용 스레드가 지속적으로 switcher.programInput.videoSource.value와 switcher.previewInput.videoSource.value를 확인하여 현재 PGM 및 PVW 입력 ID를 가져온다.  
  5. 현재 상태를 이전 상태와 비교한다. 변경이 감지되면 모든 입력에 대한 새로운 탈리 정보와 함께 on\_tally\_update 신호를 발생시킨다. 이 폴링 방식은 PyATEMMax 탈리 예제에서 보여주듯이 간단하고 효과적이다.10

#### **2.2.2. 모듈 2: GStreamer 및 DeckLink를 이용한 저지연 비디오 캡처 (별도 프로세스)**

* **근거:** 비디오 캡처 및 처리는 블로킹을 유발하는 I/O 집약적 작업이다. 이를 별도의 프로세스에 배치하면 메인 UI/탈리 처리 스레드가 멈추는 것을 방지할 수 있다. 캡처 도구로 GStreamer를 선택한 이유는 강력한 파이프라인 아키텍처, 네이티브 DeckLink 지원(decklinkvideosrc), 그리고 버퍼 및 협상에 대한 세밀한 제어가 가능하기 때문이다.41 이는 원시 FFmpeg나 OpenCV 캡처보다 우수하다.  
* **구현 단계:**  
  1. **장치 열거:** 메인 프로세스는 GStreamer의 Gst.DeviceMonitor를 사용하여 사용 가능한 모든 decklinkvideosrc 장치를 찾는다.43  
     device-number, hw-serial-number와 같은 속성을 나열하여 45 사용자가 UI에서 선택할 수 있도록 한다.  
  2. **캡처 프로세스 실행:** 사용자가 DeckLink 장치를 선택하면, 메인 프로세스는 multiprocessing.Process를 사용하여 전용 캡처 프로세스를 생성한다.  
  3. **GStreamer 파이프라인 (캡처 프로세스 내):** 캡처 프로세스는 GStreamer 파이프라인을 구성하고 실행한다.  
     * **파이프라인 문자열:** decklinkvideosrc device-number=0\! videoconvert\! video/x-raw,format=BGR\! appsink name=sink emit-signals=true  
     * **decklinkvideosrc:** DeckLink 카드를 위한 소스 엘리먼트. device-number는 메인 프로세스에서 전달받는다.41  
     * **videoconvert:** 비디오를 CPU에서 사용 가능한 형식으로 변환한다.  
     * **capsfilter:** video/x-raw,format=BGR와 같은 capsfilter를 사용하여 다음 단계(예: NumPy 배열 처리)에 필요한 픽셀 형식을 명시적으로 요청한다.46 이는 성공적인 포맷 협상에 매우 중요하다.47  
     * **appsink:** 이 특수 싱크 엘리먼트는 Python 애플리케이션이 파이프라인에서 직접 비디오 버퍼(프레임)를 가져올 수 있게 한다.49  
       emit-signals=true 속성이 핵심이다.  
  4. **버퍼 처리:** 캡처 프로세스는 콜백 함수를 appsink의 new-sample 신호에 연결한다. 이 콜백 내에서 Gst.Buffer를 가져와 NumPy 배열로 변환한 후, 공유 메모리 블록에 쓴다(2.2.3에서 상세 설명).  
  5. **오류 처리:** 메인 프로세스는 캡처 프로세스를 모니터링한다. 캡처 프로세스 자체는 GStreamer 버스 감시(pipeline.get\_bus().add\_signal\_watch())를 설정하여 GST\_MESSAGE\_ERROR와 같은 오류 메시지나 장치 연결 해제와 같은 이벤트를 수신하여 정상적인 종료 또는 재시작을 시도할 수 있다.50

#### **2.2.3. 모듈 3: 공유 메모리를 통한 프로세스 간 비디오 처리**

* **근거:** 비디오 프레임과 같은 대용량 NumPy 배열을 표준 multiprocessing.Queue나 Pipe를 통해 프로세스 간에 전달하는 것은 피클링(직렬화)을 포함하므로 매우 느리고 CPU 집약적이다. Python 3.8 이상에서 제공되는 multiprocessing.shared\_memory는 두 프로세스가 동일한 물리 RAM 블록에 접근하게 하여 모든 복사 및 직렬화 오버헤드를 제거한다.53  
* **구현:**  
  1. 메인 프로세스는 충분한 크기(예: BGR의 경우 width \* height \* 3)의 shared\_memory.SharedMemory 블록을 생성한다. 이 블록의 고유 이름을 캡처 프로세스 생성 시 전달한다.  
  2. 캡처 프로세스는 이 이름으로 공유 메모리 블록에 연결한다.  
  3. appsink 콜백에서 캡처 프로세스는 프레임 버퍼를 가져와 그 내용을 공유 메모리 블록에 직접 쓴다.  
  4. 이제 메인 프로세스(특히 인코딩 스레드)는 언제든지 공유 메모리 블록에서 최신 프레임을 직접 읽을 수 있으며, 데이터를 복사하지 않고 이 메모리 위치를 가리키는 NumPy 배열을 생성한다: np.ndarray(shape, dtype=dtype, buffer=shm.buf).53

#### **2.2.4. 모듈 4: FFmpeg 인코딩 및 SRT 스트리밍 (메인 프로세스, 별도 스레드)**

* **근거:** 이 로직은 기존 vMix 구현과 대체로 동일하지만, NDI 소스에서 읽는 대신 공유 메모리 블록에서 원시 프레임을 읽는다. UI 블로킹을 피하기 위해 자체 스레드에서 실행되어야 한다.  
* **구현:**  
  1. subprocess.Popen에 전달할 FFmpeg 명령을 인자 리스트로 구성한다.  
  2. **입력:** 파이프를 통한 입력을 사용한다: \-f rawvideo \-pix\_fmt bgr24 \-s 640x360 \-i pipe:0.  
  3. **인코딩:** 기존의 GPU 가속 인코딩 파라미터(-c:v h264\_nvenc, \-preset ultrafast, \-tune zerolatency 등)를 사용한다.56  
  4. **출력:** MediaMTX 서버로의 SRT 스트림을 출력한다: \-f mpegts srt://\<server\_ip\>:\<port\>.  
  5. **프로세스 관리:** "워치독(watchdog)" 패턴을 사용한다. 메인 스레드는 stdin과 stderr를 파이프로 리디렉션하여 FFmpeg subprocess를 시작한다.  
  6. 인코딩 스레드는 공유 메모리 블록에서 프레임을 읽어 FFmpeg 프로세스의 stdin 파이프로 쓴다.  
  7. 별도의 모니터링 스레드는 FFmpeg 프로세스의 stderr 파이프를 비차단 방식으로 읽어 UI에 표시할 진행 정보(프레임 속도, 비트레이트 등)를 파싱한다.59 이를 통해 FFmpeg 프로세스가 충돌하거나 예기치 않게 종료되었는지 감지할 수 있다.

### **2.3. 인프라 영향 평가**

제안된 아키텍처는 기존 클라우드 인프라에 미치는 영향을 최소화하도록 설계되었다.

* **백엔드, MediaMTX, 프론트엔드:** 변경이 필요 없다. PD 소프트웨어는 vMix에 연결되든 ATEM에 연결되든, 원본 계획서(4.1.4, 4.4.2)에 정의된 대로 H.264 Baseline 비디오와 Opus 오디오를 포함하는 표준화된 SRT 스트림을 생성할 것이다. 서버 측 구성 요소는 PGM 피드의 원본 소스에 대해 알 필요가 없으며(agnostic), 이는 현재 아키텍처의 핵심 강점이다.

---

## **Part 3: NDI Proxy 표준화 제안 평가**

사용자는 PD 소프트웨어에서 전송되는 비디오 스트림을 항상 640x360 해상도의 NDI Proxy 소스를 사용하여 표준화하는 흥미로운 아이디어를 제안했다. 이 섹션에서는 이에 대한 상세한 분석과 권장 사항을 제공한다.

### **3.1. 사용자 제안 워크플로우 분석**

사용자의 제안을 Blackmagic ATEM 소스에 적용하면 다음과 같은 데이터 파이프라인이 생성된다:

1. **ATEM PGM 출력:** ATEM 스위처가 SDI/HDMI로 PGM 피드를 출력한다.  
2. **캡처:** DeckLink 카드가 SDI/HDMI 신호를 캡처한다.  
3. **NDI 변환:** 캡처된 신호는 NDI 스트림을 생성할 수 있는 소프트웨어(예: 별도의 vMix 인스턴스, NDI 플러그인이 설치된 OBS 등)로 전달되어야 한다. 이 소프트웨어는 고해상도 SDI 신호를 NDI Proxy 스트림으로 변환한다.  
4. **ReturnFeed PD 소프트웨어 수집:** PD 소프트웨어는 이렇게 새로 생성된 NDI Proxy 소스에 연결한다.  
5. **SRT 인코딩:** PD 소프트웨어는 NDI Proxy 프레임을 읽고, FFmpeg 프로세스는 이를 MediaMTX 서버로 보낼 최종 SRT 스트림으로 인코딩한다.

### **3.2. 효율성, 지연 시간 및 복잡성 분석**

* **지연 시간:** 이 제안된 워크플로우는 최소 두 가지 중요한 지연 시간 요소를 추가한다:  
  1. NDI 변환 소프트웨어(vMix/OBS)는 처리 지연(캡처 카드 입력 디코딩, 처리, NDI 인코딩)을 추가한다.  
  2. NDI 프로토콜 자체는 네트워크 지연을 추가한다.27

     이러한 복합적인 지연은 ReturnFeed 소프트웨어가 자체 SRT 인코딩을 시작하기도 전에 발생하므로, 75ms 미만의 목표를 달성할 가능성이 매우 낮다.  
* **자원 활용:** 이 워크플로우는 매우 비효율적이다. 사용자의 컴퓨터에서 다음을 실행해야 한다:  
  1. ATEM Software Control (선택 사항이지만 일반적).  
  2. NDI 변환 애플리케이션 (vMix 또는 OBS와 같이 상당한 자원을 소모).  
  3. ReturnFeed PD 소프트웨어.  
     이는 CPU와 GPU에 큰 부담을 주며, 여러 개의 실패 지점(points of failure)을 만든다.  
* **복잡성:** 최종 사용자의 설정이 훨씬 더 복잡해진다. ATEM을 ReturnFeed에 연결하기 위해 세 번째 소프트웨어를 설치하고 구성해야 한다.

### **3.3. 권장 사항: 입력이 아닌 출력에서 표준화**

* **목표는 옳지만, 방법은 비효율적이다:** MediaMTX 서버가 항상 표준화된 저해상도, 저비트레이트 스트림을 수신하도록 보장하려는 사용자의 근본적인 목표는 절대적으로 옳다. 이는 서버 측 로직을 단순화하고 모바일 클라이언트에게 일관된 경험을 보장한다.  
* **권장 아키텍처는 목표를 더 효율적으로 달성한다:** Part 2에서 제안된 아키텍처는 동일한 목표를 훨씬 더 효율적으로 달성한다. 표준화는 PD 소프트웨어 내의 최종 인코딩 단계에서 이루어진다.  
  * **직접 경로:** ATEM (SDI) → DeckLink → GStreamer (원시 캡처) → FFmpeg (640x360으로 리사이즈 및 SRT 인코딩).  
  * 이 경로는 직접적이고, 소프트웨어 단계를 최소화하며, 가능한 가장 낮은 지연 시간을 도입한다. 고해상도 소스를 640x360으로 리사이즈하는 것은 FFmpeg에게는 간단한 작업이며 GPU 가속도 가능하다.  
* **최종 권장 사항:** **NDI Proxy 표준화 제안을 기각**하고, 직접 캡처 및 인코딩 아키텍처를 채택할 것을 권장한다. PD 소프트웨어의 책임은 소스(vMix NDI 또는 ATEM/DeckLink)를 추상화하고, *항상* 표준화된 640x360 H.264/Opus SRT 스트림을 출력으로 생성하는 것이어야 한다. 이는 사용자가 원하는 결과를 유지하면서 성능을 극대화하고 복잡성을 최소화한다.  
* **표 3.1: 워크플로우 비교 \- NDI Proxy 대 직접 캡처**  
  * **목적:** 두 접근 방식을 시각적으로 명확하게 대조하여 직접 캡처 방식의 우수성을 명백히 하고, 사용자의 의사 결정을 돕는 핵심 도구로 활용한다.  
  * **내용:**

| 지표 | NDI Proxy 워크플로우 | 직접 캡처 워크플로우 | 우위 |
| :---- | :---- | :---- | :---- |
| **예상 추가 지연 시간** | 100-200ms+ (NDI 인코딩 \+ 네트워크) | \< 1-2 프레임 (\~16-33ms) | **직접 캡처** |
| **CPU/GPU 부하** | 높음 (3개 앱 동시 실행) | 중간 (단일 통합 앱) | **직접 캡처** |
| **사용자 설정 복잡성** | 높음 (추가 소프트웨어 필요) | 낮음 (단일 설정) | **직접 캡처** |
| **소프트웨어 종속성** | 3개 (ATEM, NDI 변환기, ReturnFeed) | 2개 (ATEM, ReturnFeed) | **직접 캡처** |
| **실패 지점** | 많음 | 적음 | **직접 캡처** |

---

## **Part 4: 전략적 권장 사항 및 단계별 로드맵**

이 마지막 파트에서는 ReturnFeed 내에서 Blackmagic Design 지원의 개발, 출시 및 미래 진화를 위한 전략적 프레임워크를 제공한다.

### **4.1. 단계별 구현 로드맵**

개발 노력을 관리하고 사용자에게 점진적으로 가치를 제공하기 위해 단계별 접근 방식을 권장한다.

* **1단계: MVP \- 핵심 ATEM 지원 (목표: 3개월 주기)**  
  * **기능:** ATEM Mini, Mini Pro/ISO, SDI 시리즈에 대한 탈리 및 PGM 리턴 피드 지원.  
  * **기술 구현:** 탈리를 위해 PyATEMMax 사용. DeckLink Mini Recorder 4K로부터의 PGM 피드를 위해 GStreamer/공유 메모리/FFmpeg 캡처 파이프라인 구현. 장치 선택 UI 업데이트.  
  * **목표:** 이 인기 있고 저렴한 스위처를 사용하는 가장 큰 시장 부문(프로슈머 및 소규모 스튜디오)을 공략한다.  
* **2단계: 전문가용 확장 (목표: MVP 출시 후 3-6개월)**  
  * **기능:** ATEM Constellation 시리즈 지원 추가. PD 소프트웨어를 통한 기본 Blackmagic 카메라 제어(조리개, 게인, 블랙 레벨) 구현 시작.  
  * **기술 구현:** Constellation 모델과의 PyATEMMax 호환성 검증. 장치 추상화 계층 및 UI를 확장하여 PyATEMMax 라이브러리를 통해 카메라 제어 명령을 전송하도록 구현.32  
  * **목표:** 전문 방송 사용자를 대상으로 하고, 프리미엄 가격 책정 계층의 기반이 될 강력한 새로운 가치 제안을 도입한다.  
* **3단계: 클라우드 및 고급 통합 (목표: MVP 출시 후 6-12개월)**  
  * **기능:** 미디어 관리를 위한 Blackmagic Cloud와의 통합 탐색.34 BMD의 자체 스트리밍 브리지 제품을 잠재적인 대체 리턴 경로로 지원하는 방안 연구.33  
  * **기술 구현:** Blackmagic Cloud API 및 해당 에코시스템과의 통합 가능성을 평가하기 위한 R\&D 프로젝트 수행. 필요 시 장기적인 안정성을 위해 탈리 모듈을 공식 SDK를 사용하도록 리팩토링할 수 있다.  
  * **목표:** ReturnFeed를 Blackmagic 에코시스템의 깊이 통합된 파트너로 포지셔닝하여 엔터프라이즈 수준의 워크플로우를 지원한다.

### **4.2. 최종 사용자를 위한 권장 하드웨어 스택**

문서에는 필요한 하드웨어에 대한 명확한 가이드가 제공되어야 한다.

* **입문/프로슈머:**  
  * **스위처:** ATEM Mini Pro ISO ($875) 16  
  * **캡처 카드:** DeckLink Mini Recorder 4K ($215) 24  
  * **총 추가 비용:** 약 $1090  
* **전문가/스튜디오:**  
  * **스위처:** ATEM 1 M/E Constellation HD ($1,095) 또는 4K ($1,975) 34  
  * **캡처 카드:** DeckLink Duo 2 ($545) 23 (향후 다중 캡처 채널이 필요할 경우 대비).  
  * **총 추가 비용:** 약 $1640 이상

### **4.3. 결론 분석: 시장 기회 및 경쟁 포지셔닝**

Blackmagic Design 지원 추가는 단순한 기능 확장이 아니라 근본적인 전략적 전환이다. 이는 ReturnFeed를 틈새 시장의 "vMix 유틸리티"에서 **범용적이고 하드웨어에 구애받지 않는 원격 협업 플랫폼**으로 변모시킨다.

* **시장 확장:** 개인 크리에이터부터 대규모 방송사에 이르기까지 방대하고 충성도 높은 Blackmagic Design 사용자 기반에 제품을 개방한다.64  
* **경쟁적 해자(Moat):** 소프트웨어(vMix) 및 저가형 하드웨어(BMD) 스위칭 시장의 두 지배적인 플레이어를 모두 지원함으로써, 한 에코시스템만 지원하는 잠재적 경쟁업체에 비해 상당한 경쟁 우위를 확보한다.  
* **미래 대비:** 장치 추상화 계층을 갖춘 제안된 아키텍처는 플랫폼을 미래에 대비하게 한다. 향후 다른 스위처(예: Tricaster, Ross)에 대한 지원을 추가하는 것은 전체 애플리케이션을 재설계하는 것이 아니라 새로운 장치별 구현을 작성하는 문제로 축소된다. 이는 ReturnFeed가 현장 하드웨어에 관계없이 하이브리드 및 원격 라이브 프로덕션을 위한 최고의 솔루션으로 장기적인 성장을 이룰 수 있도록 포지셔닝한다.

#### **참고 자료**

1. SDK and Software \- ATEM Switchers \- Blackmagic Design, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/developer/products/atem/sdk-and-software](https://www.blackmagicdesign.com/developer/products/atem/sdk-and-software)  
2. ATEM Switchers \- Blackmagic Design, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/developer/products/atem](https://www.blackmagicdesign.com/developer/products/atem)  
3. ATEM Switchers SDK \- Blackmagic Design, 7월 18, 2025에 액세스, [https://documents.blackmagicdesign.com/DeveloperManuals/ATEMSDKManual.pdf?\_v=1739865610000](https://documents.blackmagicdesign.com/DeveloperManuals/ATEMSDKManual.pdf?_v=1739865610000)  
4. BlackMagic Design ATEM Mini remote access methods \- TalOrg, 7월 18, 2025에 액세스, [https://www.tal.org/tutorials/atem-mini-remote](https://www.tal.org/tutorials/atem-mini-remote)  
5. View topic \- Where can I get the UDP commands manual of the ATEM \- Blackmagic Forum, 7월 18, 2025에 액세스, [https://forum.blackmagicdesign.com/viewtopic.php?f=4\&t=120403](https://forum.blackmagicdesign.com/viewtopic.php?f=4&t=120403)  
6. Welcome to the Open Switcher documentation — OpenSwitcher 0.1.0 documentation, 7월 18, 2025에 액세스, [https://docs.openswitcher.org/](https://docs.openswitcher.org/)  
7. PyATEMMax | A Python library to monitor and control Blackmagic Design ATEM video switchers., 7월 18, 2025에 액세스, [https://clvlabs.github.io/PyATEMMax/](https://clvlabs.github.io/PyATEMMax/)  
8. clvLabs/PyATEMMax: A Python library to monitor and control Blackmagic Design ATEM video switchers. \- GitHub, 7월 18, 2025에 액세스, [https://github.com/clvLabs/PyATEMMax](https://github.com/clvLabs/PyATEMMax)  
9. About | PyATEMMax, 7월 18, 2025에 액세스, [https://clvlabs.github.io/PyATEMMax/about/](https://clvlabs.github.io/PyATEMMax/about/)  
10. Docs \- Examples \- tally | PyATEMMax, 7월 18, 2025에 액세스, [https://clvlabs.github.io/PyATEMMax/docs/examples/tally/](https://clvlabs.github.io/PyATEMMax/docs/examples/tally/)  
11. pyatem·PyPI, 7월 18, 2025에 액세스, [https://pypi.org/project/pyatem/](https://pypi.org/project/pyatem/)  
12. Using the Python module — OpenSwitcher 0.1.0 documentation, 7월 18, 2025에 액세스, [https://docs.openswitcher.org/python.html](https://docs.openswitcher.org/python.html)  
13. Blackmagic Design ATEM Protocol \- HARMAN Professional Forums, 7월 18, 2025에 액세스, [https://proforums.harman.com/amx/discussion/10437/blackmagic-design-atem-protocol](https://proforums.harman.com/amx/discussion/10437/blackmagic-design-atem-protocol)  
14. Tutorial丨How ATEM Mini Pro connect with NDI source \- RGBlink \- YouTube, 7월 18, 2025에 액세스, [https://www.youtube.com/watch?v=bDcXOld4PiI](https://www.youtube.com/watch?v=bDcXOld4PiI)  
15. Bridging the NDI gap to ATEM: Blackmagic in the IP World \- Holdan, 7월 18, 2025에 액세스, [https://www.holdan.co.uk/news/Bridging+the+NDI+gap+to+ATEM%3A+Blackmagic+in+the+IP+World](https://www.holdan.co.uk/news/Bridging+the+NDI+gap+to+ATEM%3A+Blackmagic+in+the+IP+World)  
16. ATEM Mini Extreme ISO G2 \- Blackmagic Design, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/products/atemmini/techspecs](https://www.blackmagicdesign.com/products/atemmini/techspecs)  
17. ATEM Mini – Getting Started | Blackmagic Design, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/products/atemmini/gettingstarted](https://www.blackmagicdesign.com/products/atemmini/gettingstarted)  
18. How to Use Blackmagic ATEM Mini Pro with StreamYard, 7월 18, 2025에 액세스, [https://streamyard.com/blog/how-to-use-atem-mini-pro-with-streamyard](https://streamyard.com/blog/how-to-use-atem-mini-pro-with-streamyard)  
19. Does Atem Mini pro ISO also require a capture card? (On Laptop) \- Reddit, 7월 18, 2025에 액세스, [https://www.reddit.com/r/blackmagicdesign/comments/xz356f/does\_atem\_mini\_pro\_iso\_also\_require\_a\_capture/](https://www.reddit.com/r/blackmagicdesign/comments/xz356f/does_atem_mini_pro_iso_also_require_a_capture/)  
20. Developer | Blackmagic Design, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/developer](https://www.blackmagicdesign.com/developer)  
21. Blackmagic DeckLink output support | OBS Forums, 7월 18, 2025에 액세스, [https://obsproject.com/forum/threads/blackmagic-decklink-output-support.58096/](https://obsproject.com/forum/threads/blackmagic-decklink-output-support.58096/)  
22. Key and Fill Output from vMix to a Blackmagic Switcher \- YouTube, 7월 18, 2025에 액세스, [https://www.youtube.com/watch?v=6C5QhnuIcbo](https://www.youtube.com/watch?v=6C5QhnuIcbo)  
23. DeckLink | Blackmagic Design, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/products/decklink](https://www.blackmagicdesign.com/products/decklink)  
24. Blackmagic Design DeckLink Mini Recorder 4K BDLKMINIREC4K B\&H, 7월 18, 2025에 액세스, [https://www.bhphotovideo.com/c/product/1281032-REG/blackmagic\_design\_bdlkminirec4k\_decklink\_mini\_recorder\_4k.html](https://www.bhphotovideo.com/c/product/1281032-REG/blackmagic_design_bdlkminirec4k_decklink_mini_recorder_4k.html)  
25. BMD DeckLink Mini Recorder 4K \- ShopFSI.com, 7월 18, 2025에 액세스, [https://www.shopfsi.com/BMD-DeckLink-Mini-Recorder-4K-p/bmd.decklink-minirecorder4k.htm](https://www.shopfsi.com/BMD-DeckLink-Mini-Recorder-4K-p/bmd.decklink-minirecorder4k.htm)  
26. Blackmagic DeckLink Mini Recorder 4K \- NLFX Professional, 7월 18, 2025에 액세스, [https://www.nlfxpro.com/blackmagic-decklink-mini-recorder-4k/](https://www.nlfxpro.com/blackmagic-decklink-mini-recorder-4k/)  
27. Is NDI as good as SDI? A Comprehensive Comparison \- Medialooks, 7월 18, 2025에 액세스, [https://medialooks.com/articles/is-ndi-as-good-as-sdi-a-comprehensive-comparison/](https://medialooks.com/articles/is-ndi-as-good-as-sdi-a-comprehensive-comparison/)  
28. SDI vs. NDI for new mid sized installation. : r/VIDEOENGINEERING \- Reddit, 7월 18, 2025에 액세스, [https://www.reddit.com/r/VIDEOENGINEERING/comments/srklk5/sdi\_vs\_ndi\_for\_new\_mid\_sized\_installation/](https://www.reddit.com/r/VIDEOENGINEERING/comments/srklk5/sdi_vs_ndi_for_new_mid_sized_installation/)  
29. NDI latency vs SDI \- WATCHOUT FORUM \- Dataton, 7월 18, 2025에 액세스, [https://forum.dataton.com/topic/2858-ndi-latency-vs-sdi/](https://forum.dataton.com/topic/2858-ndi-latency-vs-sdi/)  
30. Developer \- SDK and Software \- Blackmagic Design, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/developer/products/camera/sdk-and-software](https://www.blackmagicdesign.com/developer/products/camera/sdk-and-software)  
31. Camera Control \- ATEM SDI \- Blackmagic Design, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/products/atemsdi/cameracontrol](https://www.blackmagicdesign.com/products/atemsdi/cameracontrol)  
32. Camera control — OpenSwitcher 0.1.0 documentation, 7월 18, 2025에 액세스, [https://docs.openswitcher.org/commands/camera.html](https://docs.openswitcher.org/commands/camera.html)  
33. Blackmagic Streaming Processors, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/products/blackmagicstreamingprocessors](https://www.blackmagicdesign.com/products/blackmagicstreamingprocessors)  
34. Products | Blackmagic Design, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/products](https://www.blackmagicdesign.com/products)  
35. Best Practices for Designing Selection Controls Lesson \- Uxcel, 7월 18, 2025에 액세스, [https://app.uxcel.com/courses/ui-components-n-patterns/selection-controls-best-practices-324](https://app.uxcel.com/courses/ui-components-n-patterns/selection-controls-best-practices-324)  
36. Best Practices for Notifications UI Design: UX Tips, Popular Use Cases \- Setproduct, 7월 18, 2025에 액세스, [https://www.setproduct.com/blog/notifications-ui-design](https://www.setproduct.com/blog/notifications-ui-design)  
37. Input Settings \- vMix User Guide, 7월 18, 2025에 액세스, [https://www.vmix.com/help25/InputSettings.html](https://www.vmix.com/help25/InputSettings.html)  
38. Input Settings \- General \- vMix User Guide, 7월 18, 2025에 액세스, [https://www.vmix.com/help23/InputSettingsGeneral.html](https://www.vmix.com/help23/InputSettingsGeneral.html)  
39. Input Settings \- Position. \- vMix User Guide, 7월 18, 2025에 액세스, [https://www.vmix.com/help24/InputSettingsPosition.html](https://www.vmix.com/help24/InputSettingsPosition.html)  
40. Inputs \- vMix User Guide, 7월 18, 2025에 액세스, [https://www.vmix.com/help24/Inputs.html](https://www.vmix.com/help24/Inputs.html)  
41. decklinkvideosrc \- GStreamer, 7월 18, 2025에 액세스, [https://gstreamer.freedesktop.org/documentation/decklink/decklinkvideosrc.html](https://gstreamer.freedesktop.org/documentation/decklink/decklinkvideosrc.html)  
42. GStreamer vs FFmpeg \- Reddit, 7월 18, 2025에 액세스, [https://www.reddit.com/r/gstreamer/comments/1g8cuf0/gstreamer\_vs\_ffmpeg/](https://www.reddit.com/r/gstreamer/comments/1g8cuf0/gstreamer_vs_ffmpeg/)  
43. gst-python/examples/record\_sound.py at master \- GitHub, 7월 18, 2025에 액세스, [https://github.com/GStreamer/gst-python/blob/master/examples/record\_sound.py](https://github.com/GStreamer/gst-python/blob/master/examples/record_sound.py)  
44. GstDevice \- GStreamer, 7월 18, 2025에 액세스, [https://gstreamer.freedesktop.org/documentation/gstreamer/gstdevice.html](https://gstreamer.freedesktop.org/documentation/gstreamer/gstdevice.html)  
45. decklinkvideosink: GStreamer Bad Plugins 1.0 Plugins Reference Manual \- Collabora, 7월 18, 2025에 액세스, [https://people.collabora.com/\~nicolas/rist/html/gst-plugins-bad-plugins-decklinkvideosink.html](https://people.collabora.com/~nicolas/rist/html/gst-plugins-bad-plugins-decklinkvideosink.html)  
46. Gstreamer \+ Decklink \+ Nvidia \- Blackmagic Forum • View topic, 7월 18, 2025에 액세스, [https://forum.blackmagicdesign.com/viewtopic.php?f=12\&t=222046](https://forum.blackmagicdesign.com/viewtopic.php?f=12&t=222046)  
47. Negotiation \- GStreamer, 7월 18, 2025에 액세스, [https://gstreamer.freedesktop.org/documentation/additional/design/negotiation.html](https://gstreamer.freedesktop.org/documentation/additional/design/negotiation.html)  
48. Caps negotiation \- GStreamer, 7월 18, 2025에 액세스, [https://gstreamer.freedesktop.org/documentation/plugin-development/advanced/negotiation.html](https://gstreamer.freedesktop.org/documentation/plugin-development/advanced/negotiation.html)  
49. How to use Gstreamer AppSink in Python \- LifeStyleTransfer, 7월 18, 2025에 액세스, [https://lifestyletransfer.com/how-to-use-gstreamer-appsink-in-python/](https://lifestyletransfer.com/how-to-use-gstreamer-appsink-in-python/)  
50. GstGError \- GStreamer, 7월 18, 2025에 액세스, [https://gstreamer.freedesktop.org/documentation/gstreamer/gsterror.html](https://gstreamer.freedesktop.org/documentation/gstreamer/gsterror.html)  
51. Cloud Lab Gstreamer+Python Use Case, 7월 18, 2025에 액세스, [https://api.aiotcloud.nxp.com.cn/static/2024-9-27/tdnDK8N2r5i.MX93-Gstreamer-(2)-python\_EN.pdf](https://api.aiotcloud.nxp.com.cn/static/2024-9-27/tdnDK8N2r5i.MX93-Gstreamer-\(2\)-python_EN.pdf)  
52. Gstreamer, how recover from (rtmpsink) error \- python \- Stack Overflow, 7월 18, 2025에 액세스, [https://stackoverflow.com/questions/27905606/gstreamer-how-recover-from-rtmpsink-error](https://stackoverflow.com/questions/27905606/gstreamer-how-recover-from-rtmpsink-error)  
53. multiprocessing.shared\_memory — Shared memory for direct access across processes — Python 3.13.5 documentation, 7월 18, 2025에 액세스, [https://docs.python.org/3/library/multiprocessing.shared\_memory.html](https://docs.python.org/3/library/multiprocessing.shared_memory.html)  
54. Efficiently Sharing Large Numpy Arrays Between Processes in Python \- Medium, 7월 18, 2025에 액세스, [https://medium.com/@python-javascript-php-html-css/efficiently-sharing-large-numpy-arrays-between-processes-in-python-2c265b37d653](https://medium.com/@python-javascript-php-html-css/efficiently-sharing-large-numpy-arrays-between-processes-in-python-2c265b37d653)  
55. Using large numpy arrays and pandas dataframes with multiprocessing | Emilio's Blog, 7월 18, 2025에 액세스, [https://e-dorigatti.github.io/python/2020/06/19/multiprocessing-large-objects.html](https://e-dorigatti.github.io/python/2020/06/19/multiprocessing-large-objects.html)  
56. Developer \- SDK and Software \- Blackmagic Design, 7월 18, 2025에 액세스, [https://www.blackmagicdesign.com/developer/products/streaming/sdk-and-software](https://www.blackmagicdesign.com/developer/products/streaming/sdk-and-software)  
57. GPU Based Video Rotation Using Python on Ubuntu | by amirsina torfi \- Medium, 7월 18, 2025에 액세스, [https://medium.com/machine-learning-mindset/gpu-based-video-rotation-using-python-on-ubuntu-8377160bdd](https://medium.com/machine-learning-mindset/gpu-based-video-rotation-using-python-on-ubuntu-8377160bdd)  
58. Best Settings for H264\_Nvenc To Minimize Latency? (FFMPEG) \- Stack Overflow, 7월 18, 2025에 액세스, [https://stackoverflow.com/questions/59779205/best-settings-for-h264-nvenc-to-minimize-latency-ffmpeg](https://stackoverflow.com/questions/59779205/best-settings-for-h264-nvenc-to-minimize-latency-ffmpeg)  
59. How to pipe an FFmpeg output and pass it to a Python variable?, 7월 18, 2025에 액세스, [https://superkogito.github.io/blog/2020/03/19/ffmpeg\_pipe.html](https://superkogito.github.io/blog/2020/03/19/ffmpeg_pipe.html)  
60. FFMPEG in suprocess and print stderr for monitoring \- TouchDesigner forum, 7월 18, 2025에 액세스, [https://forum.derivative.ca/t/ffmpeg-in-suprocess-and-print-stderr-for-monitoring/130384](https://forum.derivative.ca/t/ffmpeg-in-suprocess-and-print-stderr-for-monitoring/130384)  
61. Getting realtime progress of ffmpeg / subprocess \- Maya \- Tech-Artists.Org, 7월 18, 2025에 액세스, [https://www.tech-artists.org/t/getting-realtime-progress-of-ffmpeg-subprocess/15360](https://www.tech-artists.org/t/getting-realtime-progress-of-ffmpeg-subprocess/15360)  
62. Blackmagic Design ATEM Mini Extreme ISO SWATEMMINICEXTISO B\&H, 7월 18, 2025에 액세스, [https://www.bhphotovideo.com/c/product/1625669-REG/blackmagic\_design\_atem\_extreme\_iso\_switchter.html](https://www.bhphotovideo.com/c/product/1625669-REG/blackmagic_design_atem_extreme_iso_switchter.html)  
63. Blackmagic Design Decklink Duo 2 4-channel 3G-SDI Video Card \- Sweetwater, 7월 18, 2025에 액세스, [https://www.sweetwater.com/store/detail/DecklinkDuo2--blackmagic-design-decklink-duo-2-4-channel-3g-sdi-video-card](https://www.sweetwater.com/store/detail/DecklinkDuo2--blackmagic-design-decklink-duo-2-4-channel-3g-sdi-video-card)  
64. Should I get a Hardware Switcher (Atem mini pro) or Capture Card for multicam streaming? The benefits of Capture card seem to outweigh those of hardware switcher. More versatility through Vmix and 4k output mainly. Am I wrong? : r/VIDEOENGINEERING \- Reddit, 7월 18, 2025에 액세스, [https://www.reddit.com/r/VIDEOENGINEERING/comments/1gwnqvw/should\_i\_get\_a\_hardware\_switcher\_atem\_mini\_pro\_or/](https://www.reddit.com/r/VIDEOENGINEERING/comments/1gwnqvw/should_i_get_a_hardware_switcher_atem_mini_pro_or/)  
65. PRO Controllers for EVERY budget you can use with VMix, ATEM and TriCaster\! \- YouTube, 7월 18, 2025에 액세스, [https://www.youtube.com/watch?v=Ka06gDQ3TsM](https://www.youtube.com/watch?v=Ka06gDQ3TsM)