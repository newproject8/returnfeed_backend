ì¶”ê°€ ì •ë³´:

https://returnfeed.net/tally_test.html
ìœ„ í˜ì´ì§€ê°€ íƒˆë¦¬ì™€, webrtcì˜ìƒì´ ë‚˜ì˜¤ëŠ”ê²ƒì¸ë°

ìŠ¤ë§ˆíŠ¸í°ë„ ë¸Œë¼ìš°ì €ì—ì„œë„ ì˜ìƒì´ ë‚˜ì˜¨ë‹¤.

ë‹¨,

ìš°ë¶„íˆ¬ì„œë²„ì™€ ê°™ì€ ê³µìœ ê¸°ì— ì ‘ì†í•œ ì™€ì´íŒŒì´ ëª¨ë“œì¼ë•Œë§Œ ì˜ìƒì´ ì˜ ë‚˜ì˜¨ë‹¤.

ë‹¤ë¥¸ ê³µìœ ê¸°ë¼ë©´ ì™€ì´íŒŒì´ë¡œí•´ë„ ìŠ¤ë§ˆíŠ¸í°ì—ì„œ ì˜ìƒì´ ì•ˆë‚˜ì˜¨ë‹¤.

ìŠ¤íƒ­ë°”ì´ ìŠ¤íƒ­ìœ¼ë¡œ í•´ê²°í•´ ë‚˜ê°”ìœ¼ë©´ ì¢‹ê² ë‹¤.
ë‚´ê°€ ê°€ì¥ ì •í™•í•œ í•´ê²°ì„ ìœ„í•´ì„œ ì–´ë–¤ê²ƒë“¤ì„ ì¶”ê°€ë¡œ ë„ˆì—ê²Œ ì œê³µí•´ì•¼ í• ì§€ ë§í•´ì¤˜ë„ ì¢‹ê² ë‹¤.

ì•„ë˜ ì£¼ì†ŒëŠ” ì˜¤ì§ ì˜ìƒ ìŠ¤íŠ¸ë¦¼ë§Œ í•˜ëŠ”ë°
ì–´ëŠ ì»´í“¨í„° ì–´ëŠ ë¸Œë¼ìš°ì € ì–´ëŠ ì¸í„°ë„·ìƒí™©(wifi, lte)ì—ì„œë„ ëª¨ë‘ ì˜ ë‚˜ì˜¨ë‹¤.
http://returnfeed.net:8889/pgm_srt_raw/


ì ‘ì†í˜ì´ì§€ ì†ŒìŠ¤ì½”ë“œ :
ì£¼ì†Œ :
https://returnfeed.net/tally_test.html


<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ReturnFeed Live</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gmarket+Sans+TTF:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-pvw: #00A36C;
            --color-pgm: #D41728;
            --tally-border-width: 24px;
            --color-blue: #00c6ff;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Gmarket Sans TTF', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none; user-select: none;
        }
        .screen {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column;
            transition: opacity 0.5s ease-out;
        }
        .hidden { opacity: 0; pointer-events: none; }

        .splash-screen { background: #000; z-index: 9999; }
        .logo-container { animation: pulse 2s infinite; }
        .logo-text { font-size: 32px; font-weight: 700; fill: white; }
        .logo-text .feed { fill: var(--color-blue); }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        .setup-screen { background: #1a1a1a; padding: 2rem; text-align: center; }
        .setup-status { font-size: 1.125rem; color: #9ca3af; margin-top: 2rem; height: 1.75rem; }
        .setup-form { width: 100%; max-width: 24rem; opacity: 0; transform: translateY(-1rem); transition: all 0.5s ease; }
        .setup-form.ready { opacity: 1; transform: translateY(0); }
        .setup-label { display: block; text-align: left; font-size: 1.125rem; font-weight: 500; margin-bottom: 0.75rem; }
        .setup-select {
            background: #374151; border: 2px solid #4b5563; color: white;
            font-size: 1.25rem; border-radius: 0.5rem; width: 100%;
            padding: 1rem; appearance: none; text-align: center; cursor: pointer;
        }
        .setup-select:focus { outline: none; border-color: #3b82f6; }

        .player-screen { background: #000; }
        .video-container { position: relative; width: 100%; height: 100%; background: #000; }
        #videoElement { width: 100%; height: 100%; object-fit: cover; }
        
        .tally-container {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none; transition: box-shadow 0.1s ease-in-out;
        }
        .pgm-tally { box-shadow: 0 0 0 var(--tally-border-width) var(--color-pgm) inset; }
        .pvw-tally { box-shadow: 0 0 0 var(--tally-border-width) var(--color-pvw) inset; }

        .video-overlay {
            position: absolute; inset: 0;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.6);
            z-index: 20;
            gap: 1rem;
        }
        .overlay-button {
            background: rgba(0, 198, 255, 0.9);
            border: none; border-radius: 50%;
            width: 80px; height: 80px;
            font-size: 2rem; color: white; cursor: pointer;
            backdrop-filter: blur(10px);
            display: flex; justify-content: center; align-items: center;
        }
        .overlay-message {
            color: #e5e5e5; font-size: 1rem; text-align: center;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        .controls-overlay {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: linear-gradient(0deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            padding: 3rem 1.5rem 1.5rem; z-index: 30;
            opacity: 0; transform: translateY(100%);
            transition: all 0.4s ease;
        }
        .controls-overlay.visible { opacity: 1; transform: translateY(0); }
        .settings-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; }
        .setting-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 1rem; background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.12); border-radius: 0.75rem;
        }
        .setting-label { font-size: 0.9rem; font-weight: 500; }
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #4a5568; transition: .4s; border-radius: 24px;
        }
        .slider:before {
            position: absolute; content: ""; height: 18px; width: 18px;
            left: 3px; bottom: 3px; background-color: white;
            transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #38a169; }
        input:checked + .slider:before { transform: translateX(20px); }
    </style>
</head>
<body>
    <div id="splashScreen" class="screen splash-screen">
        <div class="logo-container">
            <svg width="200" height="50" viewBox="0 0 200 50">
                <text x="0" y="35" class="logo-text">Return<tspan class="feed">Feed</tspan></text>
            </svg>
        </div>
    </div>
    <div id="setupScreen" class="screen setup-screen hidden">
        <div class="logo-container">
            <svg width="200" height="50" viewBox="0 0 200 50">
                <text x="0" y="35" class="logo-text">Return<tspan class="feed">Feed</tspan></text>
            </svg>
        </div>
        <p id="setupStatus" class="setup-status">ì„œë²„ì— ì—°ê²°í•˜ëŠ” ì¤‘...</p>
        <div id="setupForm" class="setup-form">
            <label for="cameraSelect" class="setup-label">ì¹´ë©”ë¼ ì„ íƒ</label>
            <select id="cameraSelect" class="setup-select">
                <option value="" disabled selected>ë‹´ë‹¹í•  ì¹´ë©”ë¼ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
            </select>
        </div>
    </div>
    <div id="playerScreen" class="screen player-screen hidden">
        <div class="video-container">
            <video id="videoElement" playsinline muted></video>
            <div id="tallyContainer" class="tally-container"></div>
            <div id="videoOverlay" class="video-overlay hidden"></div>
        </div>
        <div id="controlsOverlay" class="controls-overlay">
            <div class="settings-grid">
                <div class="setting-item">
                    <span class="setting-label">ì§„ë™</span>
                    <label class="switch">
                        <input type="checkbox" id="vibrationToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
        </div>
    </div>

<script>
class ReturnFeedApp {
    constructor() {
        this.dom = {
            splash: document.getElementById('splashScreen'),
            setup: document.getElementById('setupScreen'),
            player: document.getElementById('playerScreen'),
            setupStatus: document.getElementById('setupStatus'),
            setupForm: document.getElementById('setupForm'),
            cameraSelect: document.getElementById('cameraSelect'),
            video: document.getElementById('videoElement'),
            tally: document.getElementById('tallyContainer'),
            videoOverlay: document.getElementById('videoOverlay'),
            controls: document.getElementById('controlsOverlay'),
            vibrationToggle: document.getElementById('vibrationToggle'),
        };

        this.state = {
            myCamera: null,
            tally: { program: null, preview: null },
            lastTally: 'off',
            isOverlayVisible: false,
            settings: this.loadSettings(),
            userInteracted: false,
        };

        this.ws = null;
        this.pc = null;

        this.init();
    }

    init() {
        this.showSplashScreen()
            .then(() => {
                this.dom.setup.classList.remove('hidden');
                this.animateSetupScreen();
            });
        
        this.connectWebSocket();
        this.setupEventListeners();
        this.updateSettingsUI();
    }

    async showSplashScreen() {
        return new Promise(resolve => setTimeout(() => {
            this.dom.splash.classList.add('hidden');
            resolve();
        }, 1200));
    }

    async animateSetupScreen() {
        const steps = ["ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë¶„ì„ ì¤‘...", "ì„œë²„ì™€ ë™ê¸°í™” ì¤‘...", "ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ"];
        for (let i = 0; i < steps.length; i++) {
            await new Promise(resolve => setTimeout(() => {
                this.dom.setupStatus.textContent = steps[i];
                if (i === steps.length - 1) {
                    this.dom.setupStatus.style.opacity = '0';
                    this.dom.setupForm.classList.add('ready');
                }
                resolve();
            }, 800));
        }
    }

    showPlayerScreen() {
        this.dom.setup.classList.add('hidden');
        this.dom.player.classList.remove('hidden');
        this.connectWebRTC();
    }
    
    setupEventListeners() {
        this.dom.cameraSelect.addEventListener('change', () => this.handleCameraSelect());
        this.dom.player.addEventListener('click', () => {
             this.handleUserInteraction();
             this.toggleControlsOverlay();
        });
        this.dom.vibrationToggle.addEventListener('change', (e) => {
            this.state.settings.vibration = e.target.checked;
            this.saveSettings();
        });
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) this.reconnectIfNeeded();
        });
    }

    handleUserInteraction() {
        if (!this.state.userInteracted) {
            this.state.userInteracted = true;
            console.log('User interaction detected.');
        }
    }

    handleCameraSelect() {
        const selectedValue = this.dom.cameraSelect.value;
        if (!selectedValue) return;

        this.handleUserInteraction();

        const [numStr, ...nameParts] = selectedValue.split(':');
        this.state.myCamera = { number: parseInt(numStr), name: nameParts.join(':') };
        
        this.dom.vibrationToggle.disabled = (this.state.myCamera.number === 0);
        if (this.state.myCamera.number === 0) this.dom.vibrationToggle.checked = false;

        this.showPlayerScreen();
    }

    toggleControlsOverlay() {
        this.state.isOverlayVisible = !this.state.isOverlayVisible;
        this.dom.controls.classList.toggle('visible', this.state.isOverlayVisible);
    }
    
    connectWebSocket() {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) return;
        this.ws = new WebSocket("wss://returnfeed.net/ws/");
        this.ws.onopen = () => {
            console.log("WebSocket Connected.");
            this.ws.send(JSON.stringify({ command: 'get_full_state' }));
        };
        this.ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'input_list' || data.type === 'full_state') {
                    this.updateCameraOptions(data.inputs || {});
                }
                if (data.type === 'tally_update' || data.type === 'full_state') {
                    this.state.tally = { program: data.program, preview: data.preview };
                    this.updateTallyState();
                }
            } catch (e) {}
        };
        this.ws.onclose = () => setTimeout(() => this.connectWebSocket(), 3000);
        this.ws.onerror = () => this.ws.close();
    }

    updateCameraOptions(inputs) {
        const select = this.dom.cameraSelect;
        while (select.children.length > 1) select.removeChild(select.lastChild);

        Object.entries(inputs).forEach(([num, name]) => {
            const option = document.createElement('option');
            option.value = `${num}:${name}`;
            option.textContent = `CAM ${num}: ${name.substring(0, 15)}${name.length > 15 ? '...' : ''}`;
            select.appendChild(option);
        });

        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = '---';
        select.appendChild(separator);
        
        const pgmOption = document.createElement('option');
        pgmOption.value = '0:PGM Only';
        pgmOption.textContent = 'PGMë§Œ ë³´ê¸° (Tally ê¸°ëŠ¥ OFF)';
        select.appendChild(pgmOption);
    }
    
    async connectWebRTC() {
        this.updateVideoOverlay('connecting', 'ì„œë²„ì— ì—°ê²° ì¤‘...');
        if (this.pc) {
            this.pc.close();
            this.pc = null;
        }
        
        this.pc = new RTCPeerConnection({
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });
        
        this.pc.ontrack = (event) => {
            console.log("Stream track received.");
            if (this.dom.video.srcObject !== event.streams[0]) {
                this.dom.video.srcObject = event.streams[0];
            }
            // [í•µì‹¬ ë¡œì§ 1] ì‚¬ìš©ìê°€ ì´ì „ì— ìƒí˜¸ì‘ìš©í–ˆë‹¤ë©´, ì¦‰ì‹œ ì¬ìƒ ì‹œë„
            if (this.state.userInteracted) {
                this.tryAutoplay();
            } else {
                // ìƒí˜¸ì‘ìš©ì´ ì—†ì—ˆë‹¤ë©´ ì¬ìƒ ë²„íŠ¼ í‘œì‹œ
                this.updateVideoOverlay('ready', 'ì¬ìƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”');
            }
        };

        this.pc.onconnectionstatechange = () => {
            console.log(`WebRTC state: ${this.pc.connectionState}`);
            if (this.pc.connectionState === 'failed') {
                this.updateVideoOverlay('failed', 'ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        };

        try {
            this.pc.addTransceiver('video', { direction: 'recvonly' });
            // ìŒì„± íŠ¸ë™ì€ ì œì™¸í•˜ê³  ì˜ìƒë§Œ ìš”ì²­í•˜ì—¬ ì•ˆì •ì„± í–¥ìƒ
            // this.pc.addTransceiver('audio', { direction: 'recvonly' });
            const offer = await this.pc.createOffer();
            await this.pc.setLocalDescription(offer);

            const response = await fetch("https://returnfeed.net/pgm_srt_raw/whep", {
                method: 'POST', mode: 'cors',
                headers: { 'Content-Type': 'application/sdp' },
                body: offer.sdp
            });

            if (!response.ok) throw new Error(`WHEP request failed: ${response.status}`);
            const answerSdp = await response.text();
            await this.pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });

        } catch (error) {
            console.error("WebRTC Connection Error:", error);
            this.updateVideoOverlay('failed', 'ì—°ê²° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    }
    
    async tryAutoplay() {
        try {
            await this.dom.video.play();
            console.log("Playback started successfully.");
            this.updateVideoOverlay('hidden');
        } catch (error) {
            console.error("Autoplay failed:", error.name, error.message);
            // ìë™ ì¬ìƒ ì‹¤íŒ¨ ì‹œ ìˆ˜ë™ ì¬ìƒ ë²„íŠ¼ í‘œì‹œ
            if (error.name === "NotAllowedError") {
                 this.updateVideoOverlay('ready', 'ì¬ìƒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”');
            } else {
                 this.updateVideoOverlay('failed', 'ì¬ìƒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ');
            }
        }
    }


    updateVideoOverlay(status, message = '') {
        const overlay = this.dom.videoOverlay;
        overlay.innerHTML = '';
        overlay.classList.remove('hidden');

        const messageEl = document.createElement('p');
        messageEl.className = 'overlay-message';
        messageEl.textContent = message;

        switch (status) {
            case 'connecting':
                overlay.appendChild(messageEl);
                break;
            case 'ready':
                const playButton = document.createElement('button');
                playButton.className = 'overlay-button';
                playButton.innerHTML = 'â–¶';
                playButton.onclick = () => {
                    this.handleUserInteraction();
                    this.tryAutoplay();
                };
                overlay.appendChild(playButton);
                if(message) overlay.appendChild(messageEl);
                break;
            case 'failed':
                const retryButton = document.createElement('button');
                retryButton.className = 'overlay-button';
                retryButton.innerHTML = 'ğŸ”„';
                retryButton.onclick = () => this.connectWebRTC();
                
                overlay.appendChild(messageEl);
                overlay.appendChild(retryButton);
                break;
            case 'hidden':
                overlay.classList.add('hidden');
                break;
        }
    }
    
    updateTallyState() {
        if (!this.state.myCamera) return;
        
        let currentTally = 'off';
        if (this.state.myCamera.number !== 0) {
            if (this.state.myCamera.number === this.state.tally.program) currentTally = 'pgm';
            else if (this.state.myCamera.number === this.state.tally.preview) currentTally = 'pvw';
        }

        if (this.state.lastTally !== currentTally) {
            this.state.lastTally = currentTally;
            this.dom.tally.className = 'tally-container';
            if (currentTally !== 'off') {
                this.dom.tally.classList.add(`${currentTally}-tally`);
            }
            if (this.state.settings.vibration && navigator.vibrate) {
                if (currentTally === 'pvw') navigator.vibrate([80, 40, 80]);
                if (currentTally === 'pgm') navigator.vibrate(250);
            }
        }
    }

    loadSettings() {
        try {
            const saved = localStorage.getItem('returnfeed_settings_v3_final');
            return saved ? JSON.parse(saved) : { vibration: true };
        } catch {
            return { vibration: true };
        }
    }
    
    saveSettings() {
        localStorage.setItem('returnfeed_settings_v3_final', JSON.stringify(this.state.settings));
    }
    
    updateSettingsUI() {
        this.dom.vibrationToggle.checked = this.state.settings.vibration;
    }
    
    reconnectIfNeeded() {
        if (this.ws.readyState !== WebSocket.OPEN) this.connectWebSocket();
        if (this.state.myCamera && (!this.pc || this.pc.connectionState === 'failed' || this.pc.connectionState === 'disconnected')) {
            this.connectWebRTC();
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new ReturnFeedApp();
});
</script>
</body>
</html>
